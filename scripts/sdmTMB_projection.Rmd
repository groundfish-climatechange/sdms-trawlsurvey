---
title: "sdmTMB_projection"
author: "Owen Liu"
date: "7/9/2021"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r, include=FALSE}
# devtools::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(tidyverse)
library(lubridate)
library(rnaturalearth)
library(sf)
library(here)
# vista is Eric Ward's library for looking at outputs
library(vista)
library(cowplot)
library(RANN)

knitr::opts_chunk$set(echo = TRUE)
options(dplyr.summarise.inform=FALSE)
```

```{r}
# ggplot theme
plot_theme <-   theme_minimal()+
  theme(text=element_text(family="sans",size=10,color="black"),
        legend.text = element_text(size=14),
        axis.title=element_text(family="sans",size=14,color="black"),
        axis.text=element_text(family="sans",size=8,color="black"),
        panel.grid.major = element_line(color="gray50",linetype=3))
theme_set(plot_theme)
```


```{r}
# spatial background map
# load west cost land for mapping
coast <- ne_states(country='United States of America',returnclass = 'sf') %>% 
  filter(name %in% c('California','Oregon','Washington','Nevada')) %>%
  st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km")

```


# Purpose

Using species distribution models fit to hindcast ROMS data, project future species distributions using projected ROMS data. The models were fitted using `sdmTMB` in script `sdmTMB models.Rmd`. We now take those fitted models and apply them to the projected oceanographic data.

# Load Fitted Models and Projected ROMS

## Define Spatial Domain

For a spatial domain of projection, we use the maximal extent of the trawl survey data. This avoids out-of-domain projection of the SDMs. This spatial domain was created by finding a convex hull of all trawl survey locations, then cropping it using a coastline.

```{r}
projection_extent <- read_rds(here::here('data','cropped_domain_for_projected_sdms.rds'))
ggplot()+
  geom_sf(data=coast)+
  geom_sf(data=projection_extent,fill='red',alpha=0.5)+
  labs(title="Domain for Projected SDMs")

# does this look right?
```


## Load Models

```{r}
sdms <- read_rds(here::here('model output','four species sdmTMB test.rds')) %>% 
  group_split(spp) %>% 
  # split the nested data frame of models into a list of 4 (one list of models per species)
  set_names(c('canary rockfish','darkblotched rockfish','sablefish','shortspine thornyhead'))

##
sable_model <- sdms %>% pluck('sablefish','model',8)
```

## Load Projected ROMS data

The projected ROMS gridded data have been processed into a tibble that includes the average value of bottom temperature and bottom oxygen for each year at each grid point, along with the average value of that environmental variable over the 30d leading up to July 31 (the midpoint of the trawl survey season) each year. These values are for each of 3 global climate models, making a total of 12 variables.

```{r}
# pre-processed and clipped to projection extent
roms <- read_rds(here('data','roms_for_sdm_projection.rds'))
```

```{r,eval=FALSE}
# only run these chunks if you need to reproduce the roms (UTM, clipped to projection extent) data
roms <- read_rds(here::here('data','mean_30dmean_bt_ox_allmodels_1980_2100.rds'))
glimpse(roms)
```

Calculate latitude and longitude in UTM coordinates, which is what the models were fitted with. NOTE: this is also where we crop these ROMS data to the designated SDM projection domain (see above)

```{r, eval=FALSE}
roms <- roms %>% 
  # convert to sf object
  st_as_sf(coords=c('lon','lat'),crs=4326,remove=F) %>%
  # transform to UTM zone 10
  st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km") %>%
  # crop to SDM extent
  st_intersection(projection_extent) %>%
  # add new coords as vars
  mutate(latitude = sf::st_coordinates(.)[,2],
         longitude = sf::st_coordinates(.)[,1]) %>%
  # convert back to normal df
  st_set_geometry(NULL)
```

```{r}
# write_rds(roms,here('data','roms_for_sdm_projection.rds'))
```


## Load Habitat Data

This is subject to change, but one of the predictors in the SDMs right now is a habitat variable---proportion of hard substrate. Using a composite substrate data layer, we have separately calculated the proportion of edge ROMS grid cell that consists of hard substrate, and will use that in these projections.

```{r}
hab <- read_rds(here('data','substrate','prop_hard_by_ROMS_cell.rds'))

# the roms grid, to match habitat values to lat/lon
roms_ll <- read_rds(here::here('data','roms_latlon_key_topleft_start.rds')) %>% 
  mutate(roms_cell=row_number())

hab <- hab %>% 
  left_join(roms_ll,by="roms_cell") %>% 
  dplyr::select(lon,lat,prop_hard,depth_m) %>% 
  rename(prop_hard_mixed=prop_hard)

# hab_sf <- hab %>% st_as_sf(coords=c('lon','lat'),crs=4326) %>% 
#   st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km")

# ggplot()+geom_sf(data=hab_sf,aes(col=prop_hard_mixed))+geom_sf(data=coast)
```


# Predict

In order to use the fitted models to project on ROMS data, we have to make sure the models have all the variables that were used in model fitting. Working with our example model for now...

```{r}
sable_model$formula
```

This model used proportion hard substrate, along with 30-day lagged mean (normalized) temperature and oxygen. We need to use the same normalization to transform the projected variables.

## Prediction Function

Function to make predictions for one model. For now we only use the "midpoint" environmental data (i.e., the 30 day lag from July 31st)

```{r}
# give the function a model object from sdmTMB, and a global climate model, either 'hadl','gfdl', or 'ipsl'
make_predictions <- function(modelobj,gcm="hadl"){

  original_model_data <- modelobj$data
  # need to use the original (hindcast) environmental data to scale the projected data
  mean_t <- mean(original_model_data$mean_temp_roms_30,na.rm=T)
  sd_t <- sd(original_model_data$mean_temp_roms_30,na.rm=T)
  mean_oxy <- mean(original_model_data$mean_oxygen_roms_30,na.rm=T)
  sd_oxy <- sd(original_model_data$mean_oxygen_roms_30,na.rm=T)
  
  # create a new tibble with the projected data for the chosen gcm
  newdata <- roms %>% 
    ## NOTE: WE LOSE A TON OF DATA HERE, SOMETHING MAY BE WRONG WITH THE HABITAT DATA
    left_join(hab,by=c("lat","lon")) %>% 
    drop_na() %>% 
    dplyr::select(year,lat,lon,latitude,longitude,prop_hard_mixed,depth_m,contains(paste0("30d_",gcm)))
  
  temperature <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('temperature') %>% 
    mutate(mean_temp_roms_30_norm=(temperature-mean_t)/sd_t)
  
  oxygen <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('oxygen') %>% 
    mutate(mean_oxygen_roms_30_norm=(oxygen-mean_oxy)/sd_oxy)

  newdata <- newdata %>% 
    bind_cols(temperature) %>% 
    bind_cols(oxygen) %>% 
    dplyr::select(-temperature,-oxygen) %>%
    mutate(year=as.double(year))
  
  # years to predict
  yrs <- sort(unique(newdata$year))
  # now we can make the predictions
  predicted_cpue_km2 <- predict(modelobj,newdata,return_tmb_object=T,extra_time=yrs)
  #Error: Some new time elements were found in `newdata`. For now, make sure only time elements from the original dataset are present. If you would like to predict on new time elements, see the `extra_time` argument in `?sdmTMB:::predict.sdmTMB`.
}
```

Example

```{r}
sable_future <- make_predictions(sable_model)
glimpse(sable_future$data)
```

# Plots

## Annual Map

```{r}
# pretty grid
gr <- projection_extent %>% st_make_grid(cellsize=10,what='centers') %>% st_as_sf() %>% 
  st_intersection(projection_extent)
gr_xy <- st_coordinates(gr)

map_year <- function(modelobj,yr_vec=c(2000),return_pred_df=F){
  # scale for the legend, common within species
  scl <- c(0,quantile(exp(modelobj$data$est),0.99))
  df <- modelobj$data %>% 
    filter(year%in%yr_vec) %>% 
    group_by(longitude,latitude) %>% 
    summarise(est=mean(est,na.rm=T) %>% exp()) %>% 
    # rescale super large positive outliers for mapping purposes
    mutate(est=ifelse(est>scl[2],scl[2],est))
  # match nearest neighbors from predictions to grid
  pred_points <- df %>% dplyr::select(longitude,latitude) %>% as.matrix()
  nns <- nn2(pred_points,gr_xy,k=1)$nn.idx
  gr_pred <- gr_xy %>% as_tibble() %>% mutate(est=df$est[nns])
  
  bbox=st_bbox(projection_extent)
  
  if(return_pred_df) {out <- gr_pred}
  
  else{
      out<-ggplot(coast)+
        geom_sf()+
        # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
        # scale_color_viridis_c()+
        geom_raster(data=gr_pred,aes(x=X,y=Y,fill=est),interpolate=F)+
        scale_fill_viridis_c(limits=scl)+
        xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
        labs(x="",y="",fill="CPUE")
  }
  out
}
map_year(sable_future,yr_vec=(c(2010)))
```

## Difference Map

Compare a map for a given year to the historical average (1980-2010)

```{r}
#1980-2010 baseline
make_comparison_map <- function(modelobj,yr=2050){
  basepred <- map_year(modelobj,yr_vec=1980:2010,return_pred_df = T)
  newpred <- map_year(modelobj,yr_vec=yr,return_pred_df = T) %>% 
    mutate(est_comp=est) %>% dplyr::select(-est)
  both <- basepred %>% 
    left_join(newpred,by=c('X','Y')) %>% 
    mutate(diffpred=est_comp-est)
  
  bbox=st_bbox(projection_extent)
  
  out<-ggplot(coast)+
        geom_sf()+
        # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
        # scale_color_viridis_c()+
        geom_raster(data=both,aes(x=X,y=Y,fill=diffpred),interpolate=F)+
        scale_fill_gradient2(low = "red", mid = "white", high = "purple")+
        # scale_fill_viridis_c(direction = -1)+
        xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
        labs(x="",y="",fill="Difference")
  out
}
make_comparison_map(sable_future,yr=2050)

make_comparison_map(sdms %>% pluck('darkblotched rockfish','model',8) %>% make_predictions(),yr=2050)
```


## Index of Abundance

```{r}
make_index <- function(modelobj,gcm="hadl"){
  sppname <- unique(modelobj$fit_obj$data$species) %>% tools::toTitleCase()
  ind <- modelobj %>% get_index()
  p <- ind %>% 
    ggplot(aes(year,est/1000,ymax=upr/1000,ymin=lwr/1000))+
    geom_line()+
    geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,2))+
    labs(x="Year",y="Index of Abundance",title=paste(sppname, "Abundance Index"))
  p
}
```

```{r}
make_index(sable_future)
```

## Center of Gravity

Plot center of gravity over time

```{r}
make_cog <- function(modelobj,gcm="hadl"){
  sppname <- unique(modelobj$fit_obj$data$species) %>% tools::toTitleCase()
  cog <- modelobj %>% 
    get_cog() %>% 
    dplyr::select(-max_gradient,-bad_eig)

# reorganize output (X and Y coords)
  cog_x <- cog %>% filter(coord=="X")%>% 
    rename_with(~paste0(.,"_x"),all_of(c('est','lwr','upr','se'))) %>% 
    dplyr::select(-coord)
  cog_y <- cog %>% filter(coord=="Y") %>% 
    rename_with(~paste0(.,"_y"),all_of(c('est','lwr','upr','se'))) %>% 
    dplyr::select(-coord)
  cog_2d <- cog_x %>% left_join(cog_y,by='year')
  
  cog_x_plot <- cog_2d %>% 
    ggplot(aes(year,est_x,ymax=upr_x,ymin=lwr_x))+
    geom_line()+
    geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,5))+
    labs(x="Year",y="Eastings (km)",title="Center of Gravity, X")
  
  cog_y_plot <- cog_2d %>% 
    ggplot(aes(year,est_y,ymax=upr_y,ymin=lwr_y))+
    geom_line()+
    geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,5))+
    labs(x="Year",y="Northings (km)",title="Center of Gravity, Y")
  
  cog2d_timeseries <- plot_grid(cog_x_plot,cog_y_plot,nrow=2)
  
  cog_2d_sf <- cog_2d %>% st_as_sf(coords=c('est_x','est_y'),crs="+proj=utm +zone=10 +datum=WGS84 +units=km")

  bbox <- st_bbox(projection_extent)

  cog_spatial <- ggplot()+
      geom_sf(data=coast)+
      geom_sf(data=cog_2d_sf,aes(col=year))+
      labs(title=paste(sppname,"Center of Gravity"),col="Year")+
      xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])

  out <- plot_grid(cog_spatial,cog2d_timeseries,ncol=2)
  out
}
```

```{r}
make_cog(sable_future)
```

## Hovmoller Plots

Add latitude and depth bins, then plot

```{r}
make_hov <- function(modelobj){
  
  df_pred <- modelobj$data
  
  depthbins <- seq(-3500,0,by=100)
  latbins <- seq(30,50,by=0.5)
  
  out <- df_pred %>% 
    # add lat and depth bins
    mutate(latbin=latbins[findInterval(lat,vec=latbins)],
           depthbin=depthbins[findInterval(depth_m,vec=depthbins)]) %>% 
    ungroup()
  
  #summarize data by year/lat or year/depth
  
  outlat <- out %>% 
    group_by(year,latbin) %>% 
    summarise(mean_cpue=mean(est,na.rm=T))
  
  outdepth <- out %>% 
    group_by(year,depthbin) %>% 
    summarise(mean_cpue=mean(est,na.rm=T))
  
  p1 <- outlat %>% 
    ggplot(aes(year,latbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="Abundance Index by Latitude",x="Year",y="Latitude")
  
  p2 <- outdepth %>% 
    ggplot(aes(year,depthbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0),breaks = seq(-3500,0,by=300),labels=seq(-3500,0,by=300))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="Abundance Index by Depth",x="Year",y="Depth")
  
  comb <- plot_grid(p1,p2,nrow=1)
  comb
}
```

```{r}
make_hov(sable_future)
```

## Modeled Environmental Relationships

```{r}
make_env <- function(modelobj){
  df <- modelobj$data
  f <- modelobj$formula %>% as.character() %>% pluck(3)
  meanhab <- mean(df$prop_hard_mixed)
  meant <- mean(df$mean_temp_roms_30_norm)
  meano <- mean(df$mean_oxygen_roms_30_norm)
  meanlat <- mean(df$latitude)
  meanlon <- mean(df$longitude)
  
  if(grepl('prop_hard_mixed',f)){
    habdf <- tibble(prop_hard_mixed=seq(0,1,length.out=100),year=2000,
                        mean_temp_roms_30_norm=meant,mean_oxygen_roms_30_norm=meano,
                    longitude=meanlon,latitude=meanlat)
    phab <- predict(modelobj,newdata=habdf,se_fit=T)
    habplot <- ggplot(phab,aes(prop_hard_mixed,exp(est),ymin=exp(est-1.96*est_se),
                               ymax=exp(est+1.96*est_se)))+
      geom_line()+geom_ribbon(alpha=0.5)+
      labs(title="Habitat",x="Prop Hard Bottom",y="CPUE")
  } else{habplot <- ggplot(df %>% slice(1:100),aes(prop_hard_mixed, cpue_kg_km2)) + geom_blank()+
      labs(title="Habitat",x="Prop Hard Bottom",y="CPUE")}
  
  
  if(grepl('mean_temp',f)){
    tdf <- tibble(mean_temp_roms_30_norm=seq(min(df$mean_temp_roms_30_norm)+0.2,max(df$mean_temp_roms_30_norm)-0.2,length.out=100),year=2000,
                        prop_hard_mixed=meanhab,mean_oxygen_roms_30_norm=meano,
                    longitude=meanlon,latitude=meanlat)
    pt <- predict(modelobj,newdata=tdf,se_fit=T)
    tplot <- ggplot(pt,aes(mean_temp_roms_30_norm,exp(est),ymin=exp(est-1.96*est_se),
                               ymax=exp(est+1.96*est_se)))+
      geom_line()+geom_ribbon(alpha=0.5)+
      labs(title="Temperature",x="Normalized T",y="CPUE")
  }else{tplot <- ggplot(df %>% slice(1:100),aes(prop_hard_mixed, cpue_kg_km2)) + geom_blank()+
      labs(title="Temperature",x="Normalized T",y="CPUE")}
  
  
  if(grepl('mean_oxygen',f)){
    odf <- tibble(mean_oxygen_roms_30_norm=seq(min(df$mean_oxygen_roms_30_norm)+0.2,max(df$mean_oxygen_roms_30_norm)-0.2,length.out=100),year=2000,
                        prop_hard_mixed=meanhab,mean_temp_roms_30_norm=meant,
                    longitude=meanlon,latitude=meanlat)
    po <- predict(modelobj,newdata=odf,se_fit=T)
    oplot <- ggplot(po,aes(mean_oxygen_roms_30_norm,exp(est),ymin=exp(est-1.96*est_se),
                               ymax=exp(est+1.96*est_se)))+
      geom_line()+geom_ribbon(alpha=0.5)+
      labs(title="Oxygen",x="Normalized Oxygen",y="CPUE")
  }else{oplot <- ggplot(df %>% slice(1:100),aes(prop_hard_mixed, cpue_kg_km2)) + geom_blank()+
      labs(title="Oxygen",x="Normalized Oxygen",y="CPUE")}
  out <- plot_grid(habplot,tplot,oplot,nrow=1)
  out
}
```

```{r}
make_env(sdms %>% pluck('sablefish','model',1))
```

## All Together

```{r}
save_projection_plots <- function(modelobj,savedir=here::here('plots')){
  # make projection
  projection <- make_predictions(modelobj)
  
  # maps
  # historical average cpue
  baseline_cpue <- map_year(projection,yr_vec=1980:2010)
  # 2050 and 2100 relative to baseline
  diff2050 <- make_comparison_map(projection,yr=2050)
  diff2100 <- make_comparison_map(projection,yr=2100)
  
  # index of abundance, center of gravity, hovmoller plots
  ind <- make_index(projection)
  cog <- make_cog(projection)
  hov <- make_hov(projection)
  
  # environmental relationships
  env_rels <- make_env(modelobj)
  
  # save everything to file
  dir.create(savedir)
  ggsave(filename=paste0(savedir,'/baseline_cpue.png'),baseline_cpue)
  ggsave(filename=paste0(savedir,'/diff2050.png'),diff2050)
  ggsave(filename=paste0(savedir,'/diff2100.png'),diff2100)
  ggsave(filename=paste0(savedir,'/ind.png'),ind)
  ggsave(filename=paste0(savedir,'/cog.png'),cog)
  ggsave(filename=paste0(savedir,'/hov.png'),hov)
  ggsave(filename=paste0(savedir,'/environmental_affiinities.png'),env_rels)
  
  #
  print("Plots saved")
}
```

```{r,fig.width=8,fig.height=8}
sable_model1 <- sdms %>% pluck('sablefish','model',1)
sable_model8 <- sdms %>% pluck('sablefish','model',8)
save_projection_plots(sable_model1,savedir=here::here('plots','sablefish hadl 1'))
save_projection_plots(sable_model8,savedir=here::here('plots','sablefish hadl 8'))

# two for canary
canary_model1 <- sdms %>% pluck('canary rockfish','model',1)
canary_model8 <- sdms %>% pluck('canary rockfish','model',8)
save_projection_plots(canary_model1,savedir=here::here('plots','canary hadl 1'))
save_projection_plots(canary_model8,savedir=here::here('plots','canary hadl 8'))

#two for shortspine
shortspine_model1 <- sdms %>% pluck('shortspine thornyhead','model',1)
shortspine_model8 <- sdms %>% pluck('shortspine thornyhead','model',8)
save_projection_plots(shortspine_model1,savedir=here::here('plots','shortspine hadl 1'))
save_projection_plots(shortspine_model8,savedir=here::here('plots','shortspine hadl 8'))

#two for darkblotched
dark_model1 <- sdms %>% pluck('darkblotched rockfish','model',1)
dark_model8 <- sdms %>% pluck('darkblotched rockfish','model',8)
save_projection_plots(dark_model1,savedir=here::here('plots','darkblotched hadl 1'))
save_projection_plots(dark_model8,savedir=here::here('plots','darkblotched hadl 8'))
```

