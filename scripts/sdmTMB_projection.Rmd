---
title: "sdmTMB_projection"
author: "Owen Liu"
date: "7/9/2021"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r, include=FALSE}
# devtools::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(tidyverse)
library(lubridate)
library(rnaturalearth)
library(sf)
library(here)
# vista is Eric Ward's library for looking at outputs
library(vista)
library(cowplot)

knitr::opts_chunk$set(echo = TRUE)
options(dplyr.summarise.inform=FALSE)
```

```{r}
# ggplot theme
plot_theme <-   theme_minimal()+
  theme(text=element_text(family="sans",size=10,color="black"),
        legend.text = element_text(size=14),
        axis.title=element_text(family="sans",size=14,color="black"),
        axis.text=element_text(family="sans",size=8,color="black"),
        panel.grid.major = element_line(color="gray50",linetype=3))
theme_set(plot_theme)
```


```{r}
# spatial background map
# load west cost land for mapping
coast <- ne_states(country='United States of America',returnclass = 'sf') %>% 
  filter(name %in% c('California','Oregon','Washington','Nevada')) %>%
  st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km")

```


# Purpose

Using species distribution models fit to hindcast ROMS data, project future species distributions using projected ROMS data. The models were fitted using `sdmTMB` in script `sdmTMB models.Rmd`. We now take those fitted models and apply them to the projected oceanographic data.

# Load Fitted Models and Projected ROMS

## Define Spatial Domain

For a spatial domain of projection, we use the maximal extent of the trawl survey data. This avoids out-of-domain projection of the SDMs. This spatial domain was created by finding a convex hull of all trawl survey locations, then cropping it using a coastline.

```{r}
projection_extent <- read_rds(here::here('data','cropped_domain_for_projected_sdms.rds'))
ggplot()+
  geom_sf(data=coast)+
  geom_sf(data=projection_extent,fill='red',alpha=0.5)+
  labs(title="Domain for Projected SDMs")

# does this look right?
```


## Load Models

```{r}
sdms <- read_rds(here::here('model output','four species sdmTMB test.rds')) %>% 
  group_split(spp) %>% 
  # split the nested data frame of models into a list of 4 (one list of models per species)
  set_names(c('canary rockfish','darkblotched rockfish','sablefish','shortspine thornyhead'))
```

In the testing of sdmTMB, 8 different models were run for four different species. For the purposes of testing diagnostic plots, let's test the diagnostic plots on some of these 32 models.

```{r}
# here is one of the sablefish models as an example
sable_model <- sdms %>% pluck('sablefish','model',8)
```

## Load Projected ROMS data

The projected ROMS gridded data have been processed into a tibble that includes the average value of bottom temperature and bottom oxygen for each year at each grid point, along with the average value of that environmental variable over the 30d leading up to July 31 (the midpoint of the trawl survey season) each year. These values are for each of 3 global climate models, making a total of 12 variables.

```{r}
# pre-processed and clipped to projection extent
roms <- read_rds(here('data','roms_for_sdm_projection.rds'))
```

```{r,eval=FALSE}
# only run these chunks if you need to reproduce the roms (UTM, clipped to projection extent) data
roms <- read_rds(here::here('data','mean_30dmean_bt_ox_allmodels_1980_2100.rds'))
glimpse(roms)
```

Calculate latitude and longitude in UTM coordinates, which is what the models were fitted with. NOTE: this is also where we crop these ROMS data to the designated SDM projection domain (see above)

```{r, eval=FALSE}
roms <- roms %>% 
  # convert to sf object
  st_as_sf(coords=c('lon','lat'),crs=4326,remove=F) %>%
  # transform to UTM zone 10
  st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km") %>%
  # crop to SDM extent
  st_intersection(projection_extent) %>%
  # add new coords as vars
  mutate(latitude = sf::st_coordinates(.)[,2],
         longitude = sf::st_coordinates(.)[,1]) %>%
  # convert back to normal df
  st_set_geometry(NULL)
```

```{r}
# write_rds(roms,here('data','roms_for_sdm_projection.rds'))
```


## Load Habitat Data

This is subject to change, but one of the predictors in the SDMs right now is a habitat variable---proportion of hard substrate. Using a composite substrate data layer, we have separately calculated the proportion of edge ROMS grid cell that consists of hard substrate, and will use that in these projections.

```{r}
hab <- read_rds(here('data','substrate','prop_hard_by_ROMS_cell.rds'))

# the roms grid, to match habitat values to lat/lon
roms_ll <- read_rds(here::here('data','roms_latlon_key_topleft_start.rds')) %>% 
  mutate(roms_cell=row_number())

hab <- hab %>% 
  left_join(roms_ll,by="roms_cell") %>% 
  dplyr::select(lon,lat,prop_hard,depth_m) %>% 
  rename(prop_hard_mixed=prop_hard)

# hab_sf <- hab %>% st_as_sf(coords=c('lon','lat'),crs=4326) %>% 
#   st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km")

# ggplot()+geom_sf(data=hab_sf,aes(col=prop_hard_mixed))+geom_sf(data=coast)
```


# Predict

In order to use the fitted models to project on ROMS data, we have to make sure the models have all the variables that were used in model fitting. Working with our example model for now...

```{r}
sable_model$formula
```

This model used proportion hard substrate, along with 30-day lagged mean (normalized) temperature and oxygen. We need to use the same normalization to transform the projected variables.

## Prediction Function

Function to make predictions for one model. For now we only use the "midpoint" environmental data (i.e., the 30 day lag from July 31st)

```{r}
# give the function a model object from sdmTMB, and a global climate model, either 'hadl','gfdl', or 'ipsl'
make_predictions <- function(modelobj,gcm="hadl",return_tmb_object=F){

  original_model_data <- modelobj$data
  # need to use the original (hindcast) environmental data to scale the projected data
  mean_t <- mean(original_model_data$mean_temp_roms_30,na.rm=T)
  sd_t <- sd(original_model_data$mean_temp_roms_30,na.rm=T)
  mean_oxy <- mean(original_model_data$mean_oxygen_roms_30,na.rm=T)
  sd_oxy <- sd(original_model_data$mean_oxygen_roms_30,na.rm=T)
  
  # create a new tibble with the projected data for the chosen gcm
  newdata <- roms %>% 
    ## NOTE: WE LOSE A TON OF DATA HERE, SOMETHING MAY BE WRONG WITH THE HABITAT DATA
    left_join(hab,by=c("lat","lon")) %>% 
    drop_na() %>% 
    dplyr::select(year,lat,lon,latitude,longitude,prop_hard_mixed,depth_m,contains(paste0("30d_",gcm)))
  
  temperature <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('temperature') %>% 
    mutate(mean_temp_roms_30_norm=(temperature-mean_t)/sd_t)
  
  oxygen <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('oxygen') %>% 
    mutate(mean_oxygen_roms_30_norm=(oxygen-mean_oxy)/sd_oxy)

  newdata <- newdata %>% 
    bind_cols(temperature) %>% 
    bind_cols(oxygen) %>% 
    dplyr::select(-temperature,-oxygen) %>%
    mutate(year=as.double(year))
  
  # years to predict
  yrs <- sort(unique(newdata$year))
  # now we can make the predictions
  predicted_cpue_km2 <- predict(modelobj,newdata,return_tmb_object=ifelse(return_tmb_object,T,F),extra_time=yrs)
  #Error: Some new time elements were found in `newdata`. For now, make sure only time elements from the original dataset are present. If you would like to predict on new time elements, see the `extra_time` argument in `?sdmTMB:::predict.sdmTMB`.
}
```

## Project Species

```{r}
sable_future_index <- make_predictions(sable_model,return_tmb_object = T) %>% get_index()
# glimpse(sable_future)
sable_future_index %>% 
  ggplot(aes(year,est,ymax=upr,ymin=lwr))+
  geom_line()+
  geom_ribbon(fill='red',alpha=0.5)+
  scale_x_continuous(expand=c(0,2))+
  labs(x="Year",y="Index of Abundance",title="Sablefish Abundance Index")
```

## Center of Gravity

Plot center of gravity over time

```{r}
# from sdm-TMB
sable_cog <- make_predictions(sable_model,return_tmb_object = T) %>% 
  get_cog() %>% 
  dplyr::select(-max_gradient,-bad_eig)
glimpse(sable_cog)
# reorganize output (X and Y coords)
sable_cog_x <- sable_cog %>% filter(coord=="X")%>% 
  rename_with(~paste0(.,"_x"),all_of(c('est','lwr','upr','se'))) %>% 
  dplyr::select(-coord)
sable_cog_y <- sable_cog %>% filter(coord=="Y") %>% rename_with(~paste0(.,"_y"),all_of(c('est','lwr','upr','se'))) %>% 
  dplyr::select(-coord)
sable_cog_2d <- sable_cog_x %>% left_join(sable_cog_y)
```

Plot the X and Y COG components over time

```{r}
library(cowplot)
cog_x_plot <- sable_cog_2d %>% 
  ggplot(aes(year,est_x,ymax=upr_x,ymin=lwr_x))+
  geom_line()+
  geom_ribbon(fill='red',alpha=0.5)+
  scale_x_continuous(expand=c(0,5))+
  labs(x="Year",y="Eastings (km)",title="Center of Gravity, X")

cog_y_plot <- sable_cog_2d %>% 
  ggplot(aes(year,est_y,ymax=upr_y,ymin=lwr_y))+
  geom_line()+
  geom_ribbon(fill='red',alpha=0.5)+
  scale_x_continuous(expand=c(0,5))+
  labs(x="Year",y="Northings (km)",title="Center of Gravity, Y")

plot_grid(cog_x_plot,cog_y_plot,nrow=2)
```


Plot the COG spatially

```{r}
sable_cog_2d_sf <- sable_cog_2d %>% st_as_sf(coords=c('est_x','est_y'),crs="+proj=utm +zone=10 +datum=WGS84 +units=km")

bbox <- st_bbox(projection_extent)

ggplot()+
  geom_sf(data=coast)+
  geom_sf(data=sable_cog_2d_sf,aes(col=year))+
  labs(title="Sablefish Center of Gravity")+
  xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])
  
```


# Hovmoller Plots

Add latitude and depth bins, then plot

```{r}
make_hov <- function(df_pred){
  
  depthbins <- seq(-3500,0,by=100)
  latbins <- seq(30,50,by=0.5)
  
  out <- df_pred %>% 
    # add lat and depth bins
    mutate(latbin=latbins[findInterval(lat,vec=latbins)],
           depthbin=depthbins[findInterval(depth_m,vec=depthbins)]) %>% 
    ungroup()
  
  #summarize data by year/lat or year/depth
  
  outlat <- out %>% 
    group_by(year,latbin) %>% 
    summarise(mean_cpue=mean(est,na.rm=T))
  
  outdepth <- out %>% 
    group_by(year,depthbin) %>% 
    summarise(mean_cpue=mean(est,na.rm=T))
  
  p1 <- outlat %>% 
    ggplot(aes(year,latbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="Abundance Index by Latitude",x="Year",y="Latitude")
  
  p2 <- outdepth %>% 
    ggplot(aes(year,depthbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0),breaks = seq(-3500,0,by=300),labels=seq(-3500,0,by=300))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="Abundance Index by Depth",x="Year",y="Depth")
  
  comb <- plot_grid(p1,p2,nrow=1)
  comb
}

make_hov(sable_future)
```


## Abundance by Time by Latitude



## Abundance by Time by Depth