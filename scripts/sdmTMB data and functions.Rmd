---
title: "Run sdmTMB"
author: "Owen Liu"
date: "6/8/2021"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
# devtools::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(tidyverse)
library(lubridate)
library(sf)
library(here)
knitr::opts_chunk$set(echo = TRUE)
options(dplyr.summarise.inform=FALSE)
```

# Purpose

Join trawl survey data with ROMS oceanographic data and substrate data, and write an sdmTMB wrapper to run models. Actual modelling done in script `sdmTMB models.Rmd`

# Import Data

## Trawl Data

Trawl data, including a matching key to link to ROMS data. The hindcast ROMS data has values for all trawl survey locations for all times, but we just want the values matched to the actual trawl survey times/dates.

```{r}
trawl <- read_rds(here('data','nwfsc_trawl_data.rds')) %>% 
  # convert date from character to date
  mutate(date=as_date(date))
# roms time refernce
roms_time <- read_rds(here('data','roms_time_date_reference.rds'))
trawl_locs <- read_rds(here::here('data','trawl','trawlID.rds')) %>% 
  # add a dummy indicator of a "real" trawl survey location in time/space
  mutate(date=as_datetime(trawl_time,origin="1900-01-01")) %>%
  mutate(date=as_date(date)) %>%
  mutate(realTrawl=1) %>% 
  # join the roms_time reference
  left_join(roms_time) %>% 
  # select the variable we'll use to match
  select(station,date,time,lon_trawl,lat_trawl,depth_trawl,realTrawl)

trawl <- trawl %>% 
  left_join(trawl_locs,by=c("date"="date","longitude_dd"="lon_trawl","latitude_dd"="lat_trawl","depth"="depth_trawl"))
```

Filter the trawl survey data to fit within the time frame for which we have ROMS hindcast data (1980-2010)

```{r}
trawl <- trawl %>%
  filter(realTrawl==1) %>% 
  select(-realTrawl) %>% 
  # rename time to something more useful
  rename(roms_hindcast_day=time)
glimpse(trawl)
```

## ROMS data

Hindcast ROMS data matched to trawl survey locations and times

```{r}
roms <- read_rds(here::here('data','joined_30d_lagged_t_o.rds')) %>%
  # join the trawl_locs and filter by actual trawl locations and times
  left_join(trawl_locs) %>% 
  filter(realTrawl==1) %>% 
  select(-realTrawl) %>% 
  # rename time to something more useful
  rename(roms_hindcast_day=time)
glimpse(roms)
```

## Substrate Data

Here is the substrate data that Blake Feist matched to individual trawl tows.

```{r}
substrate <- read_rds(here('data','substrate','substrate_by_trawlID.rds'))
glimpse(substrate)
```


Look at the form of these data

```{r}
glimpse(trawl)
glimpse(roms)
glimpse(substrate)
```

For the ROMS data (for now), we are using modelled temperature and oxygen, lagged 30 days from each trawl survey location and time.

```{r}
roms_thin <- roms %>% 
  dplyr::select(station,lon_trawl,lat_trawl,depth_trawl,mean_temp_roms_30,mean_oxygen_roms_30)
```

# Join Datasets

# Join Trawl and ROMS

Join the two datasets together, such that we have the appropriately-matched ROMS outputs

```{r}
trawl_roms <- trawl %>% left_join(roms,by = c("date", "station", "roms_hindcast_day")) %>% 
  #clean up some columns
  dplyr::select(date,trawl_id,station,lon_trawl,lat_trawl,depth_trawl,mean_temp_roms_30,mean_oxygen_roms_30,species,cpue_kg_km2) %>% 
  # drop any rows with NAs
  drop_na()
```

```{r}
  # test <- trawl %>% left_join(roms,by = c("date", "station", "roms_hindcast_day")) %>% 
  #   #clean up some columns
  #   dplyr::select(date,trawl_id,station,lon_trawl,lat_trawl,depth_trawl,temp_roms,oxygen_roms,mean_temp_roms_30,mean_oxygen_roms_30,species,cpue_kg_km2) %>% 
  #   # drop any rows with NAs
  #   drop_na()
```


## Join Trawl and Substrate

Join the substrate data by trawl ID number.

```{r}
substrate_thin <- substrate %>% 
  dplyr::select(TRAWL_ID,prop_hard_mixed)
trawl_roms <- trawl_roms %>% 
  left_join(substrate_thin,by=c('trawl_id'="TRAWL_ID")) %>% 
  drop_na()
```


# Prepare Data for sdmTMB

Convert the trawl spatial data to UTM. 

```{r}
# convert to UTM
trawl_roms_utm <- trawl_roms %>%
  # convert to sf object
  st_as_sf(coords=c('lon_trawl','lat_trawl'),crs=4326) %>%
  # transform to UTM zone 10
  st_transform(crs = "+proj=utm +zone=10 +datum=WGS84 +units=km") %>%
  # add new coords as vars
  mutate(latitude = sf::st_coordinates(.)[,2],
         longitude = sf::st_coordinates(.)[,1]) %>%
  # convert back to normal df
  st_set_geometry(NULL)
```

We can save this version of the data so we do not have to run the join every time.

```{r}
write_rds(trawl_roms_utm,here::here('data','trawl_roms_joined.rds'))
```


# Functions to Run a Model

We'll write two functions, one to prepare a specific species for an sdmTMB model, and another to actually run an sdmTMB model with custom options

## Prepare Species' Data

This function selects a species' data from the trawl survey data, converts the spatial data to UTM, does a couple of filters for missing data, and then joins the ROMS hindcast data to it by time and location.

```{r}
prepare_species <- function(dat,spp){
  dat_sub <- dat %>% 
    filter(species==spp) %>% 
    
    # rescale depth, oxygen, and temp to be N(0,1)
    mutate(across(c(depth_trawl,mean_temp_roms_30,mean_oxygen_roms_30),~(scale(.) %>% as.vector()),.names="{.col}_norm")) %>% 
    
    # add a year indicator
    mutate(year=lubridate::year(date))
}
```

Try an example for sablefish

```{r}
sablefish_dat <- prepare_species(trawl_roms_utm,spp="sablefish")
glimpse(sablefish_dat)
```

## sdmTMB Model Function

Write a function that runs sdmTMB. It wil call the previous function to make the appropriate species data. For now, the environmental variable names are not generic (always `mean_temp_roms_30_norm` and `mean_oxygen_roms_30_norm`)

```{r}
run_sdmTMB <- function(dat,spp,nknots=400,use_depth=F,time_varying=F,spatial_field=T,hab_spline=F,env_spline=F,spline_k=3){
  # filter data for species
  modeldat <- prepare_species(dat,spp=spp)
  
  # make spde
  spde <- make_mesh(modeldat,xy_cols = c('longitude','latitude'), 
                   cutoff = 20)
  
  # model formula
  formula <- paste0("cpue_kg_km2 ~ ")
  
  # substrate relationship
  substrate <- paste("prop_hard_mixed + I(prop_hard_mixed^2)")
  #wiggly habitat relationship?
  substrate <- ifelse(hab_spline, paste0("s(prop_hard_mixed,k=",spline_k,")"),
                      substrate)
  
  # make the environmental effects
  enviro <- paste("mean_temp_roms_30_norm + 
                  I(mean_temp_roms_30_norm^2) + 
                  mean_oxygen_roms_30_norm + 
                  I(mean_oxygen_roms_30_norm^2)")
  # wiggly environmental relationships?
  enviro <- ifelse(env_spline, paste0("s(mean_temp_roms_30_norm,k=",spline_k,") + ",
                                      "s(mean_oxygen_roms_30_norm,k=",spline_k,")"),
                   enviro)
  # if depth effect, add to model formla
  if(use_depth) {
    formula = paste0(formula, " + depth + I(depth^2)")
  }
  
  time_formula = "~ -1"
  if(time_varying) {
    time_formula = paste0(time_formula, " + ", substrate, " + ", enviro)
    time_varying = as.formula(time_formula)
    time = "year"
  } else {
    formula = paste0(formula, " + ", substrate, " + ", enviro)
    time_varying = NULL
    time = "year"
  }
  
  # fit model. EW commented out quadratic roots, since those are still experimental and won't work for all spp. Also turned
  # anisotropy off for now
  m <- try( sdmTMB( 
    formula = as.formula(formula),
    time_varying = time_varying,
    spde = spde,
    time = time,
    family = tweedie(link = "log"),
    data = modeldat,
    anisotropy = FALSE,
    spatial_only = T,
    #extra_time argument necessary for prediction?
    extra_time=1980:2100,
    map_rf=ifelse(spatial_field,F,T)
  ), 
  silent=TRUE)
  
  # if(class(m)!="try-error") {
  #   write_rds(m, file=here::here('model output',
  #                                paste0(spp,'.rds')))
  # }
  if(class(m)=="try-error"){
    print(paste("Error."))
  }else{
    print(paste("Model for",spp,"complete."))
  }
  return(m)
}
```

If we wanted to use cross validation, we could do that in a couple ways. For example, with a single train/test split, we could assign 10% of the observations to the test set and not fit the model for all the folds (fitting to all folds is the default in sdmTMB_cv).

```{r eval=FALSE}
test_set = sample(1:nrow(modeldat), size = round(0.1*nrow(modeldat)), replace=FALSE)
modeldat$fold = 1
modeldat$fold[test_set] = 2
```

Alternatively we could do something like assign all points for a given year (e.g. 2018) to the test set.

```{r eval=FALSE}
modeldat$fold = ifelse(modeldat$year=="2018",2,1)
```

A third option is to use blockCV to assign the folds. If you have raster data, there's a few functions in that package (spatialAutoRange, rangeExplorer) to estimate the range -- but because those are probably difficult to estimate with the kind of data we have, I've generally used ranges in the 50-75km, which is about what's estimated for many WCBTS species.

```{r eval=FALSE}
  the_data <- sf::st_as_sf(modeldat, coords = c("longitude", "latitude"))
  sb <- spatialBlock(
    speciesData = the_data,
    species = "xxxx",
    theRange = 50,
    k = 10,
    selection = "systematic",
    showBlocks = FALSE
  )
  modeldat$fold = ifelse(sb$fold==1,2,1)
```

And then we can use sdmTMB_cv to do the estimation for each fold. Because we did the test-train split, we'll fit the model 2x, but just be interested in the 1st fit.
```{r eval = FALSE}
m_cv <- try( sdmTMB_cv( 
    formula = as.formula(formula),
    time_varying = time_varying,
    spde = spde,
    k_folds = 2,
    fold_ids = "fold",
    time = time,
    family = tweedie(link = "log"),
    data = modeldat,
    anisotropy = FALSE,
    spatial_only = T,
    #extra_time argument necessary for prediction?
    extra_time=1980:2100,
    map_rf=ifelse(spatial_field,F,T)
  ), 
  silent=TRUE)

# predicted values for the 2nd fold (test)
m_cv$data$cv_predicted[which(m_cv$data$cv_fold==2)]
# log likelihood values for the 2nd fold (test)
m_cv$data$cv_loglik[which(m_cv$data$cv_fold==2)]

total_pred_ll = sum(m_cv$data$cv_loglik[which(m_cv$data$cv_fold==2)])

```

This is the end of this script. Moving the actual modelling (i.e., the calling of this function) to a new script.