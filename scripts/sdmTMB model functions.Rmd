---
title: "sdmTMB Custom Functions"
author: "Owen Liu"
date: "6/8/2021"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r, include=FALSE}
# devtools::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(tidyverse)
library(lubridate)
library(sf)
library(here)
knitr::opts_chunk$set(echo = TRUE)
options(dplyr.summarise.inform=FALSE)
```

# Purpose

Write functions utilizing `sdmTMB` to fit and project models for west coast groundfish based on hindcast ROMS oceanographic data.

*Note: All the data required for running the functions here have been produced in the `sdmTMB data construction.Rmd` script.

```{r, message=F, echo=F, include=F}
rmarkdown::render(here::here('scripts','sdmTMB data construction.Rmd'),quiet=TRUE)
```

# Functions for Fitting

## Prepare Species' Data

This function selects a species' data from the trawl survey data, converts the spatial data to UTM, does a couple of filters for missing data, and then joins the ROMS hindcast data to it by time and location.

```{r}
prepare_species <- function(dat,spp){
  dat_sub <- dat %>% 
    filter(species==spp) %>% 
    
    # rescale depth, oxygen, and temp to be N(0,1)
    mutate(across(c(depth_trawl,mean_temp_roms_30,mean_oxygen_roms_30),~(scale(.) %>% as.vector()),.names="{.col}_norm")) %>% 
    
    # add a year indicator
    mutate(year=lubridate::year(date))
}
```

## sdmTMB Model Function

Write a function that runs sdmTMB to fit a single model. It will call the previous `prepare_species` function to make the appropriate species data. For now, the environmental variable names are not generic (always `mean_temp_roms_30_norm` and `mean_oxygen_roms_30_norm` for fitting to the ROMS data).

```{r}
run_sdmTMB <- function(dat,spp,nknots=400,use_depth=F,time_vary=F,spatial_field=T,include_substrate=T,hab_spline=F,env_spline=F,spline_k=3){
  # filter data for species
  modeldat <- prepare_species(dat,spp=spp)
  
  # make spde
  spde <- make_mesh(modeldat,xy_cols = c('longitude','latitude'), 
                   cutoff = 20)
  
  # model formula
  formula <- paste0("cpue_kg_km2 ~ ")
  
  # substrate relationship
  substrate <- paste("prop_hard_mixed + I(prop_hard_mixed^2)")
  #wiggly habitat relationship?
  substrate <- ifelse(hab_spline, paste0("s(prop_hard_mixed,k=",spline_k,")"),
                      substrate)
  if(!include_substrate) substrate=""
  
  # make the environmental effects
  enviro <- paste("mean_temp_roms_30_norm + 
                  I(mean_temp_roms_30_norm^2) + 
                  mean_oxygen_roms_30_norm + 
                  I(mean_oxygen_roms_30_norm^2)")
  # wiggly environmental relationships?
  enviro <- ifelse(env_spline, paste0("s(mean_temp_roms_30_norm,k=",spline_k,") + ",
                                      "s(mean_oxygen_roms_30_norm,k=",spline_k,")"),
                   enviro)
  # if depth effect, add to model formla
  if(use_depth) {
    formula = paste0(formula, " + depth + I(depth^2)")
  }
  
  time_formula = "~ -1"
  if(time_vary) {
    time_formula = paste0(time_formula, " + ", substrate, " + ", enviro)
    time_varying = as.formula(time_formula)
    time = "year"
  } else {
    formula = paste0(formula, " + ", substrate, " + ", enviro)
    time_varying = NULL
    time = "year"
  }
  
  # fit model. EW commented out quadratic roots, since those are still experimental and won't work for all spp. Also turned
  # set.seed(41389) # for reproducibility
  # test_set = sample(1:nrow(modeldat), size = round(0.1*nrow(modeldat)), replace=FALSE)
  # modeldat$fold = 1
  # modeldat$fold[test_set] = 2
  # anisotropy off for now
  print('running model.')
  m <- try( sdmTMB(
    formula = as.formula(formula),
    time_varying = time_varying,
    spde = spde,
    time = time,
    family = tweedie(link = "log"),
    data = modeldat,
    anisotropy = FALSE,
    spatial_only = T,
    #extra_time argument necessary for prediction?
    extra_time=1980:2100,
    control=sdmTMBcontrol(map_rf=ifelse(spatial_field,F,T))
  ),
  silent=F)


  # predicted values for the 2nd fold (test)
  # m_cv$data$cv_predicted[which(m_cv$data$cv_fold==2)]
  # log likelihood values for the 2nd fold (test)
  # m_cv$data$cv_loglik[which(m_cv$data$cv_fold==2)]

    # sum(m_cv$data$cv_loglik[which(m_cv$data$cv_fold==2)])
  
  # if(class(m)!="try-error") {
  #   write_rds(m, file=here::here('model output',
  #                                paste0(spp,'.rds')))
  # }
  if(class(m)=="try-error"){
    print(paste("Error."))
  }else{
    print(paste("Model for",spp,"complete."))
  }

  # return(m)
  return(m)

}
```

## Cross Validation Function

Similar to the function above, this function implements 2-fold cross-validation in order to return the CV log-likelihood for use in model stacking and model ensembles.

```{r}
run_sdmTMB_cv <- function(dat,spp,nknots=400,use_depth=F,time_vary=F,spatial_field=T,include_substrate=T,hab_spline=F,env_spline=F,spline_k=3,return_what='loglik'){
  # filter data for species
  modeldat <- prepare_species(dat,spp=spp)
  
  # make spde
  spde <- make_mesh(modeldat,xy_cols = c('longitude','latitude'), 
                   cutoff = 20)
  
  # model formula
  formula <- paste0("cpue_kg_km2 ~ ")
  
  # substrate relationship
  substrate <- paste("prop_hard_mixed + I(prop_hard_mixed^2)")
  #wiggly habitat relationship?
  substrate <- ifelse(hab_spline, paste0("s(prop_hard_mixed,k=",spline_k,")"),
                      substrate)
  
  if(!include_substrate) substrate=""
  
  # make the environmental effects
  enviro <- paste("mean_temp_roms_30_norm + I(mean_temp_roms_30_norm^2) + mean_oxygen_roms_30_norm + I(mean_oxygen_roms_30_norm^2)")
  # wiggly environmental relationships?
  enviro <- ifelse(env_spline, paste0("s(mean_temp_roms_30_norm,k=",spline_k,") + ",
                                      "s(mean_oxygen_roms_30_norm,k=",spline_k,")"),
                   enviro)
  # if depth effect, add to model formla
  if(use_depth) {
    formula = paste0(formula, " + depth + I(depth^2)")
  }
  
  time_formula = "~ -1"
  
  if(time_vary) {
    time_formula = paste0(time_formula, " + ", substrate, " + ", enviro)
    time_varying = as.formula(time_formula)
    time = "year"
  } else {
    formula = paste0(formula, " + ", substrate, " + ", enviro)
    time_varying = NULL
    time = "year"
  }
  
  # fit model. EW commented out quadratic roots, since those are still experimental and won't work for all spp. Also turned
  set.seed(41389) # for reproducibility
  test_set = sample(1:nrow(modeldat), size = round(0.1*nrow(modeldat)), replace=FALSE)
  modeldat$fold = 1
  modeldat$fold[test_set] = 2 
  
  print('running 2-fold CV.')
  
  m_cv <- try( sdmTMB_cv( 
    formula = as.formula(formula),
    k_folds=2,
    parallel = TRUE,
    fold_ids = modeldat$fold,
    time_varying = time_varying,
    spde = spde,
    time = time,
    family = tweedie(link = "log"),
    data = modeldat,
    anisotropy = FALSE,
    spatial_only = T,
    #extra_time argument necessary for prediction?
    # extra_time=1980:2100,
    control=sdmTMBcontrol(map_rf=ifelse(spatial_field,F,T))
  ),
  silent=T)
  if(class(m_cv)=='try-error'){
    print(paste('Error.'))
  } else{
    # tem <- m_cv %>% pluck('data')
    # print(paste('data is class',class(tem)))
    total_pred_ll = m_cv %>% 
      pluck('data') %>% 
      dplyr::filter(cv_fold==2) %>% 
      pluck('cv_loglik') %>% 
      sum()
    if(return_what=='model') return(m_cv)
    else return(total_pred_ll)
  }
}
```

## Model Stacking Function

This function takes a list of models from running the equations, stacks their posterior predictive distributions, and returns appropriate likelihood-based model weights for use in creating ensemble predictions.

```{r}
sdmTMB_stacking <- function (model_list, include_folds = NULL) 
{
    n_models <- length(model_list)
    if (is.null(include_folds)) {
        n_folds <- max(model_list[[1]]$data$cv_fold)
        include_folds <- seq_len(n_folds)
    }
    X <- matrix(0, nrow = nrow(model_list[[1]]$data), ncol = n_models)
    for (i in 1:n_models) X[, i] = model_list[[i]]$data$cv_loglik
    X <- X[which(model_list[[1]]$data$cv_fold %in% include_folds), 
        ]
    X <- exp(X)
    tot_ll = function(p, X) {
        z <- matrix(exp(p)/sum(exp(p)), ncol = 1)
        k <- log(X%*%z)
        -sum(k[which(!is.infinite(k))])
    }
    o <- optim(par = runif(n_models), fn = tot_ll, X = X)
    weights <- exp(o$par)/sum(exp(o$par))
    return(weights)
}
```

## Model Fitting Wrapper

This final, wrapper function uses the functions above to fit a series of models using `run_sdmTMB`, compare them to one another using `run_sdmTMB_cv` and `sdmTMB_stacking`, and output a nested data frame including all models, their associated options (e.g., inclusion of spatial fields, linear or GAM-type environmental relationships), and importantly, their weights to use in the ensembling of model predictions.


```{r}
model_species <- function(spp,data,use_substrate=T){

  if(!use_substrate) {
    models_to_run <-crossing(spp,spatial_field=c(F,T),env_spline=c(F,T),include_substrate=F) %>%
      mutate(model_num=row_number())
    
    out <- models_to_run %>% 
      mutate(model=purrr::pmap(list(spp=spp,spatial_field=spatial_field,env_spline=env_spline,include_substrate=include_substrate),run_sdmTMB,dat=data)) %>%
      mutate(model_cv=purrr::pmap(list(spp=spp,spatial_field=spatial_field,env_spline=env_spline,include_substrate=include_substrate),run_sdmTMB_cv,dat=data,return_what="model"))
    
  } else {
    models_to_run <- crossing(spp,spatial_field=c(F,T),hab_spline=c(F,T),env_spline=c(F,T)) %>%
      mutate(model_num=row_number())
    out <- models_to_run %>% 
      mutate(model=purrr::pmap(list(spp=spp,spatial_field=spatial_field,hab_spline=hab_spline,env_spline=env_spline),run_sdmTMB,dat=data)) %>%
      mutate(model_cv=purrr::pmap(list(spp=spp,spatial_field=spatial_field,hab_spline=hab_spline,env_spline=env_spline),run_sdmTMB_cv,dat=data,return_what="model"))
  }
  
  
  model_weights <- try(sdmTMB_stacking(out$model_cv))
  if(class(model_weights)=='try-error'){
    print(paste('Error in model stacking.'))
    out$weight=NA
  } else{
    out$weight=model_weights
  }

  out
}
```

# Functions for Projection

## Single Model Projection

Function to make predictions for one model, using the "midpoint" environmental data (i.e., the 30 day lag from July 31st). In addition, the model makes a prediction using one the RCP8.5 scenario data from one of the three Earth System Models: Hadley, GFDL, or IPSL.

```{r}
# give the function a model object from sdmTMB, and a global climate model, either 'hadl','gfdl', 'ipsl'
make_predictions <- function(modelobj,gcm="hadl"){

  original_model_data <- modelobj$data
  # need to use the original (hindcast) environmental data to scale the projected data
  mean_t <- mean(original_model_data$mean_temp_roms_30,na.rm=T)
  sd_t <- sd(original_model_data$mean_temp_roms_30,na.rm=T)
  mean_oxy <- mean(original_model_data$mean_oxygen_roms_30,na.rm=T)
  sd_oxy <- sd(original_model_data$mean_oxygen_roms_30,na.rm=T)
  
  # create a new tibble with the projected data for the chosen gcm
  newdata <- roms %>% 
    ## NOTE: WE LOSE A TON OF DATA HERE, SOMETHING MAY BE WRONG WITH THE HABITAT DATA
    left_join(hab,by=c("lat","lon")) %>% 
    drop_na() %>% 
    dplyr::select(year,lat,lon,latitude,longitude,prop_hard_mixed,depth_m,contains(paste0("30d_",gcm)))
  
  temperature <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('temperature') %>% 
    mutate(mean_temp_roms_30_norm=(temperature-mean_t)/sd_t)
  
  oxygen <- newdata %>% dplyr::select(contains('oxy')) %>% 
    set_names('oxygen') %>% 
    mutate(mean_oxygen_roms_30_norm=(oxygen-mean_oxy)/sd_oxy)

  newdata <- newdata %>% 
    bind_cols(temperature) %>% 
    bind_cols(oxygen) %>% 
    dplyr::select(-temperature,-oxygen) %>%
    mutate(year=as.double(year))
  
  # years to predict
  yrs <- sort(unique(newdata$year))
  # now we can make the predictions
  predicted_cpue_km2 <- predict(modelobj,newdata,return_tmb_object=T,extra_time=yrs)
  
  predicted_cpue_km2
}
```

## Ensemble Predictions

To create ensemble predictions, we calculate predictions for each species' model separately, then weight them using the weights established in model fitting (i.e., from `sdmTMB_stacking`). This function takes as input the dataframe result of the `model_species` function above, then makes ensemble predictions using the projections from an ESM of choice (Hadley, GFDL, or IPSL). Returns a dataframe of predicted log CPUE.

```{r}
# this function is meant to be run with a list of models that all are fit on the same data, with a common set of predictors
ensemble_predictions <- function(model_df,gcm='hadl'){
  
  # use the first model in the list to pull out the data
  original_model_data <- model_df %>% pluck('model',1,'data')
  # need to use the original (hindcast) environmental data to scale the projected data
  mean_t <- mean(original_model_data$mean_temp_roms_30,na.rm=T)
  sd_t <- sd(original_model_data$mean_temp_roms_30,na.rm=T)
  mean_oxy <- mean(original_model_data$mean_oxygen_roms_30,na.rm=T)
  sd_oxy <- sd(original_model_data$mean_oxygen_roms_30,na.rm=T)
  
  # create a new tibble with the projected data for the chosen gcm
  newdata <- roms %>% 
    ## NOTE: WE LOSE A TON OF DATA HERE, SOMETHING MAY BE WRONG WITH THE HABITAT DATA
    left_join(hab,by=c("lat","lon")) %>% 
    drop_na() %>% 
    dplyr::select(year,lat,lon,latitude,longitude,prop_hard_mixed,depth_m,contains(paste0("30d_",gcm)))
  
  temperature <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('temperature') %>% 
    mutate(mean_temp_roms_30_norm=(temperature-mean_t)/sd_t)
  
  oxygen <- newdata %>% dplyr::select(contains('oxy')) %>% 
    set_names('oxygen') %>% 
    mutate(mean_oxygen_roms_30_norm=(oxygen-mean_oxy)/sd_oxy)

  newdata <- newdata %>% 
    bind_cols(temperature) %>% 
    bind_cols(oxygen) %>% 
    dplyr::select(-temperature,-oxygen) %>%
    mutate(year=as.double(year))
  
  # years to predict
  yrs <- sort(unique(newdata$year))
  
  # model weights
  w <- model_df %>% pluck('weight')
  w <- ifelse(all(is.na(w)),rep(1,length(w)),w)
  
  model_list <- model_df %>% pluck('model')
  
  # make the predictions for all 8 models
  all_predictions <- purrr::map2_df(model_list,w,function(m,weight){
    preds <- predict(m,newdata=newdata,return_tmb_object=F,extra_time=yrs) %>% 
      mutate(weight=weight)
    preds
  })
  ens_preds <- all_predictions %>% 
    group_by(year,longitude,latitude,lat,lon,depth_m) %>% 
    summarise(ens_est=weighted.mean(est,weight)) %>% 
    ungroup()
  
  ens_preds
}
```

# Visualizing Outputs

After models have been fit and projected using trawl survey and ROMS data, we have a lot of ways to visualize the outputs.

## Annual Map

Rasterized grid for mapping prediction outputs.

```{r}
# pretty grid for raster maps
gr <- projection_extent %>% st_make_grid(cellsize=10,what='centers') %>% st_as_sf() %>% 
  st_intersection(projection_extent)
gr_xy <- st_coordinates(gr)
```

Function that maps SDM output for one year or a mean from a range of years (param `yr_vec`). Options to return the predicted data instead of the plot (`return_pred_df`) or whether or not to plot the legend (`plot_leg`)

```{r}
map_year <- function(model_ens,yr_vec=c(2000),return_pred_df=F,plot_leg=T){
  # scale for the legend, common within species
  scl <- c(0,quantile(exp(model_ens$ens_est),0.99))
  df <- model_ens %>% 
    filter(year%in%yr_vec) %>% 
    group_by(longitude,latitude) %>% 
    summarise(est=mean(ens_est,na.rm=T) %>% exp()) %>% 
    # rescale super large positive outliers for mapping purposes
    mutate(est=ifelse(est>scl[2],scl[2],est))
  # match nearest neighbors from predictions to grid
  pred_points <- df %>% dplyr::select(longitude,latitude) %>% as.matrix()
  nns <- nn2(pred_points,gr_xy,k=1)$nn.idx
  gr_pred <- gr_xy %>% as_tibble() %>% mutate(est=df$est[nns])
  
  bbox=st_bbox(projection_extent)
  
  if(return_pred_df) {out <- gr_pred %>% as_tibble()}
  
  else{
    out<-ggplot(coast)+
      geom_sf()+
      # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
      # scale_color_viridis_c()+
      geom_raster(data=gr_pred,aes(x=X,y=Y,fill=est),interpolate=F)+
      scale_fill_viridis_c(limits=scl)+
      xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
      labs(x="",y="",fill="CPUE",title='')
    if(!plot_leg) out <- out + theme(legend.position = 'None')
  }
  out
}
```

## Difference Map

Compare a map for a given year to the historical, 1980-2010 average.

```{r}
make_comparison_map <- function(model_ens,yr=2050){
  basepred <- map_year(model_ens,yr_vec=1980:2010,return_pred_df = T)
  newpred <- map_year(model_ens,yr_vec=yr,return_pred_df = T) %>% 
    mutate(est_comp=est) %>% dplyr::select(-est)
  both <- basepred %>% 
    left_join(newpred,by=c('X','Y')) %>% 
    mutate(diffpred=est_comp-est)
  
  bbox=st_bbox(projection_extent)
  
  out<-ggplot(coast)+
        geom_sf()+
        # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
        # scale_color_viridis_c()+
        geom_raster(data=both,aes(x=X,y=Y,fill=diffpred),interpolate=F)+
        scale_fill_gradient2(low = "red", mid = "white", high = "purple")+
        # scale_fill_viridis_c(direction = -1)+
        xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
        labs(x="",y="",fill="Difference")
  out
}
```

## Index of Abundance

Calculate an ensemble index of abundance. This function takes as input the dataframe result of the `model_species` function above, then makes a weighted, ensemble index of abundance using the projections from an ESM of choice (Hadley, GFDL, or IPSL) and the function `sdmTMB::get_index`.

```{r}
make_index <- function(model_df,gcm='hadl'){
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
    # model weights
  w <- model_df %>% pluck('weight')
  if(all(is.na(w))) w <- rep(1,nrow(model_df))
  # tic('making predictions')
  predictions_list <- model_df %>% pluck('model') %>% 
    purrr::map(make_predictions,gcm=gcm) 
  # toc()
  
  # tic('making indices')
  
  indices <- predictions_list %>% purrr::map_dfr(get_index)
  toc()
  
  nyr <- length(unique(indices$year))
  ws <- rep(w,each=nyr)
  
  # combined index
  ind <- indices %>%
    mutate(weight=ws) %>% 
    group_by(year) %>% 
    summarise(w.est=weighted.mean(est,w=weight)) %>% 
    ungroup()
  
  p <- ind %>%
    # ggplot(aes(year,est/1000,ymax=upr/1000,ymin=lwr/1000))+
    ggplot(aes(year,w.est/1000))+
    geom_line()+
    # geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,2))+
    labs(x="Year",y="Index of Abundance",title=paste(sppname, "Ensemble Abundance Index"))
  p
}
```

## Center of Gravity

Calculate an ensemble center of gravity time series or map. This function takes as input the dataframe result of the `model_species` function above, then makes a weighted, ensemble index of abundance using the projections from an ESM of choice (Hadley, GFDL, or IPSL) and the function `sdmTMB::get_cog`. User can choose whether to output a plot (`what='plot'`) or a dataframe recording ensemble COG over time.

```{r}
make_cog <- function(model_df,gcm='hadl',what="plot"){
  
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
  
  # model weights
  w <- model_df %>% pluck('weight')
  if(all(is.na(w))) w <- rep(1,nrow(model_df))
  
  # tic('making predictions')
  predictions_list <- model_df %>% pluck('model') %>% 
    purrr::map(make_predictions,gcm=gcm) 
  # toc()
  
  # tic('making cogs')
  
  cogs <- predictions_list %>% purrr::map_dfr(get_cog)
  # toc()
  
  nyr <- length(unique(cogs$year))
  ws <- rep(w,each=nyr)
  
  
# reorganize output (X and Y coords)
  cog_x <- cogs %>% 
    filter(coord=="X")%>% 
    rename_with(~paste0(.,"_x"),all_of(c('est','lwr','upr','se'))) %>% 
    dplyr::select(-coord) %>% 
    # add weights
    mutate(weight=ws) %>% 
    group_by(year) %>% 
    summarise(w.est_x=weighted.mean(est_x,w=weight)) %>% 
    ungroup()
  cog_y <- cogs %>% 
    filter(coord=="Y") %>% 
    rename_with(~paste0(.,"_y"),all_of(c('est','lwr','upr','se')))%>% 
    dplyr::select(-coord) %>% 
    # add weights
    mutate(weight=ws) %>% 
    group_by(year) %>% 
    summarise(w.est_y=weighted.mean(est_y,w=weight)) %>% 
    ungroup()
  cog_2d <- cog_x %>% left_join(cog_y,by='year')
  
  cog_x_plot <- cog_2d %>% 
    # ggplot(aes(year,w.est_x,ymax=upr_x,ymin=lwr_x))+
    ggplot(aes(year,w.est_x))+
    geom_line()+
    # geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,5))+
    labs(x="Year",y="Eastings (km)",title="Center of Gravity, X")
  
  cog_y_plot <- cog_2d %>% 
    # ggplot(aes(year,w.est_y,ymax=upr_y,ymin=lwr_y))+
    ggplot(aes(year,w.est_y))+
    geom_line()+
    # geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,5))+
    labs(x="Year",y="Northings (km)",title="Center of Gravity, Y")
  
  cog2d_timeseries <- plot_grid(cog_x_plot,cog_y_plot,nrow=2)
  
  cog_2d_sf <- cog_2d %>% st_as_sf(coords=c('w.est_x','w.est_y'),crs="+proj=utm +zone=10 +datum=WGS84 +units=km")

  bbox <- st_bbox(projection_extent)

  cog_spatial <- ggplot()+
      geom_sf(data=coast)+
      geom_sf(data=cog_2d_sf,aes(col=year))+
      labs(title=paste(sppname,"Center of Gravity"),col="Year")+
      xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])

  out <- plot_grid(cog_spatial,cog2d_timeseries,ncol=2)
  if(what=="plot") return(out) else return(cog_2d)
}
```

## Depth Distribution

Calculate and plot a comparative cumulative depth distribution. This function takes as input the ensemble predictions for a species (i.e, the output of `ensemble_predictions`), then compares the depth distribution of two years of data (default 2020 and 2100).

```{r}
plot_depth_distribution <- function(ens_preds,name="",start_year=2020,end_year=2100){
  y <- ens_preds %>% 
    filter(year==start_year|year==end_year) %>%
    mutate(cpue=exp(ens_est)) %>% 
    rename(depth=depth_m) %>% 
    group_by(year,depth) %>% 
    summarise(cpue=mean(cpue,na.rm=T)) %>% 
    ungroup() %>% 
    group_by(year) %>% 
    mutate(prop_cpue=cpue/sum(cpue,na.rm=T)) %>%
    arrange(desc(depth)) %>% 
    mutate(cum_cpue=cumsum(prop_cpue)) %>% 
    ungroup()
  y %>% 
    ggplot(aes(depth,cum_cpue,col=factor(year)))+
    geom_line(size=2)+
    coord_flip()+
    scale_color_manual(values=c("#2271B2","#d55e00"))+
    labs(x="Depth (m)",y="Cumulative CPUE",title=paste(name,"Predicted Depth Distribution"),col="Year")
}
```

## Distance from Shore

Using data on the distance of each ROMS cell from the coastline, calculate an ensemble weighted "distance from shore centroid" for each 0.1deg latitude band in each year. This function takes as input the ensemble predictions for a species (i.e, the output of `ensemble_predictions`).

```{r}
plot_dist_to_shore <- function(ens_preds,include_legend=T){
  d <- ens_preds %>% 
    left_join(roms_dist_to_coast,by=c("longitude","latitude")) %>% 
    group_by(year,lat) %>% 
    mutate(totest = sum(exp(ens_est))) %>% 
    mutate(rel_est=exp(ens_est)/totest) %>% 
    mutate(w.dist=rel_est*km_to_coast) %>% 
    summarise(w.dist=sum(w.dist)) %>% 
    ungroup()
  if(include_legend){
      p <- d %>% 
        ggplot(aes(lat,w.dist,col=year,group=year))+
        geom_line()+
        scale_color_viridis(option="A")+
        scale_y_continuous(limits=c(0,100))+
        coord_flip()+
        # theme(legend.position = c(0.8,0.7))+
        labs(y="Distance from Shore (km)",x="Latitude",col="Year")
  } else {
      p <- d %>% 
        ggplot(aes(lat,w.dist,col=year,group=year))+
        geom_line()+
        scale_color_viridis(option="A",guide="none")+
        scale_y_continuous(limits=c(0,100))+
        coord_flip()+
        labs(y="",x="",col="")
  }

  p
}
```

## Hovmoller Plots

Make side-by-side, Hovmoller-type plots of predicted species' CPUE by depth and latitude over time.

```{r}
make_hov <- function(model_df,gcm='hadl'){
  
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
  gcmname <- switch(gcm,hadl="Hadley",gfdl="GFDL",ipsl = "IPSL")
  
  df_pred <- ensemble_predictions(model_df,gcm=gcm)
  
  depthbins <- seq(-3500,0,by=100)
  latbins <- seq(30,50,by=0.5)
  
  out <- df_pred %>% 
    # add lat and depth bins
    mutate(latbin=latbins[findInterval(lat,vec=latbins)],
           depthbin=depthbins[findInterval(depth_m,vec=depthbins)]) %>% 
    ungroup()
  
  #summarize data by year/lat or year/depth
  
  outlat <- out %>% 
    group_by(year,latbin) %>% 
    summarise(mean_cpue=mean(ens_est,na.rm=T))
  
  outdepth <- out %>% 
    group_by(year,depthbin) %>% 
    summarise(mean_cpue=mean(ens_est,na.rm=T)) %>% 
    filter(depthbin>-2001)
  
  p1 <- outlat %>% 
    ggplot(aes(year,latbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$ens_est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="",x="Year",y="Latitude")
  
  p2 <- outdepth %>% 
    ggplot(aes(year,depthbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$ens_est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0),breaks = seq(-3500,0,by=300),labels=seq(-3500,0,by=300))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="",x="Year",y="Depth")
  
  comb <- plot_grid(p1,p2,nrow=1)
  # titlegg <- ggdraw() +
  #   draw_label(paste(sppname,gcmname))
  # plot_grid(titlegg,comb,ncol = 1, rel_heights = c(0.2, 1))
  comb
}
```

## Environmental Affinities Raster

Plot a raster heatmap of relative species CPUE across the range of bottom temperature and oxygen values found in the data. This function takes as input the ensemble predictions for a species (i.e, the output of `ensemble_predictions`), as well as a template raster of oxygen and temperature values.

```{r}
rasterize_affinities <- function(ens_preds,template_raster,return_what="plot"){

  ul <- quantile(ens_preds$ens_est,0.99)
  ll <- quantile(ens_preds$ens_est,0.01)
  dsf <- ens_preds %>% 
    filter(ens_est>ll,ens_est<ul) %>%
    mutate(abun=exp(ens_est)) %>% 
    mutate(rel_abun=abun/max(abun,na.rm=T)) %>% 
    st_as_sf(coords=c("mean_bt_30d_ipsl","mean_oxy_bottom_30d_ipsl"))
  spp_r <- dsf %>% raster::rasterize(template_raster,field="rel_abun",fun=mean)
  spp_df <- spp_r %>% raster::rasterToPoints() %>% as_tibble() %>% set_names(c('temp','oxy','abun')) %>%
    mutate(species=unique(ens_preds$species))
  # spp_df
  
  # make the plot
    
  mainp <- spp_df %>% 
    ggplot(aes(temp,oxy,fill=abun))+
    geom_tile()+
    scale_fill_viridis(na.value='white',name="Relative\nAbundance",breaks=c(0,0.25,0.5,0.75,1))+
    labs(x="",y="",title='')+
    theme(panel.background = element_rect(fill='white'),
          # panel.background = element_rect(fill=viridis_pal()(1)),
          # legend.position = c(0.1,0.7),
          # legend.background = element_rect(fill='white'),
          panel.grid.major = element_blank(),
          panel.grid.minor=element_blank())
  
  if(return_what=="legend") return(get_legend(mainp))
  else{
      
  m1 <- spp_df %>% group_by(temp) %>% summarise(m=sum(abun)) %>% 
    ggplot(aes(temp,m))+geom_area(fill='grey50')+theme_void()+
    theme(plot.margin = margin(0,-0.1,-0.1,0,'cm'))
  
  m2 <- spp_df %>% group_by(oxy) %>% summarise(m=sum(abun)) %>% 
    ggplot(aes(oxy,m))+geom_area(fill='grey50')+theme_void()+coord_flip()+
    theme(plot.margin = margin(0,0,0,0,'cm'))
  
  col1 <- plot_grid(m1,NULL,mainp+theme(legend.position='none',plot.margin = margin(0,0,0,0,'pt')),nrow=3,align='v',axis='lr',rel_heights = c(0.2,-0.07,1))
  # grobs <- ggplotGrob(row1)
  # g <- grid::rectGrob(gp = grid::gpar(col=0))
  # row1 <- plot_grid(NULL,m1,NULL,nrow=1,rel_widths = c(0.5,5,1.15))
  col2 <- plot_grid(NULL,m2,NULL,nrow=3,rel_heights = c(0.25,1,0.15))
  out <- plot_grid(col1,col2,ncol=2,rel_widths =c(1,0.25))
  # out <- plot_grid(m1,NULL,mainp+rremove('legend')+rremove(),m2,ncol=2,align='hv',rel_widths = c(1,0.25),rel_heights = c(0.25,1))
  out
  }

}
```

## All Projection Plots

This is a final wrapper function to calculate and create all of the projection plots described above, saving them within a user-defined directory.

```{r}
# make and save all plots for a given model dataframe and a given GCM
save_projection_plots <- function(model_df,gcm='hadl',savedir=here::here('plots')){
  # make ensemble projection
  tic('making ensemble projections')
  projection <- ensemble_predictions(model_df,gcm=gcm)
  toc()
  
  # maps
  # historical average cpue
  tic('making maps')
  baseline_cpue <- map_year(projection,yr_vec=1980:2010)
  # 2050 and 2100 relative to baseline
  diff2050 <- make_comparison_map(projection,yr=2050)
  diff2100 <- make_comparison_map(projection,yr=2100)
  toc()
  
  # index of abundance, center of gravity, hovmoller plots
  tic('making abundance, cog, depth, distance from shore, and hovmoller plots')
  ind <- make_index(model_df,gcm=gcm)
  cog <- make_cog(model_df,gcm=gcm)
  ddist <- plot_depth_distribution(projection)
  cdist <- plot_dist_to_shore(projection,include_legend = T)
  hov <- make_hov(model_df,gcm=gcm)
  toc()
  
  # environmental relationships
  tic('making environmental relationships')
  env_sf <- projection %>%
    # join roms data
    left_join(roms) %>% 
    dplyr::select(year,dover:ls_thornyhead,mean_bt_30d_ipsl,mean_oxy_bottom_30d_ipsl) %>%
        st_as_sf(coords=c("mean_bt_30d_ipsl","mean_oxy_bottom_30d_ipsl"))
  tempr <- raster::raster(raster::extent(st_bbox(env_sf)),nrows=150,ncol=100)
  env <- rasterize_affinities(projection,template_raster = tempr)
  toc()
  
  # save everything to file
  tic('saving plots')
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
  savedir <- paste0(savedir,'/',sppname)
  dir.create(savedir)
  savedir <- paste0(savedir,'/',gcm)
  dir.create(savedir)
  
  ggsave(filename=paste0(savedir,'/baseline_cpue.png'),baseline_cpue)
  ggsave(filename=paste0(savedir,'/diff2050.png'),diff2050)
  ggsave(filename=paste0(savedir,'/diff2100.png'),diff2100)
  ggsave(filename=paste0(savedir,'/ind.png'),ind)
  ggsave(filename=paste0(savedir,'/cog.png'),cog)
  ggsave(filename=paste0(savedir,'/depth_distribution.png'),ddist)
  ggsave(filename=paste0(savedir,'/distance_to_coast.png'),cdist)
  ggsave(filename=paste0(savedir,'/hov.png'),hov)
  ggsave(filename=paste0(savedir,'/env_affinities.png'),env)
  
  toc()
}
```