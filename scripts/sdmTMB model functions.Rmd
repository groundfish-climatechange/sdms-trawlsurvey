---
title: "sdmTMB Custom Functions"
author: "Owen Liu"
date: "6/8/2021"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r, include=FALSE}
# devtools::install_github("pbs-assess/sdmTMB")
library(sdmTMB)
library(tidyverse)
library(lubridate)
library(sf)
library(here)
library(Hmisc)
knitr::opts_chunk$set(echo = TRUE)
options(dplyr.summarise.inform=FALSE)
```

# Purpose

Write functions utilizing `sdmTMB` to fit and project models for west coast groundfish based on hindcast ROMS oceanographic data.

*Note: All the data required for running the functions here have been produced in the `sdmTMB data construction.Rmd` script.

```{r, message=F, echo=F, include=F}
rmarkdown::render(here::here('scripts','sdmTMB data construction.Rmd'),quiet=TRUE)
```

# Functions for Fitting

## Prepare Species' Data

This function selects a species' data from the trawl survey data, normalizes/scales the environmental data

```{r}
prepare_species <- function(dat,spp){
  dat_sub <- dat %>% 
    filter(species==spp) %>% 
    
    # rescale depth, oxygen, and temp to be N(0,1)
    mutate(across(c(depth_trawl,mean_temp_roms_30,mean_oxygen_roms_30),~(scale(.) %>% as.vector()),.names="{.col}_norm")) %>% 
    
    # add a year indicator
    mutate(year=lubridate::year(date))
}
```

## sdmTMB Model Function

Write a function that runs sdmTMB to fit a single model. It will call the previous `prepare_species` function to make the appropriate species data. For now, the environmental variable names are not generic (always `mean_temp_roms_30_norm` and `mean_oxygen_roms_30_norm` for fitting to the ROMS data).

```{r}
run_sdmTMB <- function(dat,spp,nknots=400,use_depth=F,time_vary=F,spatial_field=T,include_substrate=T,hab_spline=F,env_spline=F,spline_k=3){
  # filter data for species
  modeldat <- prepare_species(dat,spp=spp)
  
  # make spde
  spde <- make_mesh(modeldat,xy_cols = c('longitude','latitude'), 
                   cutoff = 20)
  
  # model formula
  formula <- paste0("cpue_kg_km2 ~ ")
  
  # substrate relationship
  substrate <- paste("prop_hard_mixed + I(prop_hard_mixed^2)")
  #wiggly habitat relationship?
  substrate <- ifelse(hab_spline, paste0("s(prop_hard_mixed,k=",spline_k,")"),
                      substrate)
  if(!include_substrate) substrate=""
  
  # make the environmental effects
  enviro <- paste("mean_temp_roms_30_norm + 
                  I(mean_temp_roms_30_norm^2) + 
                  mean_oxygen_roms_30_norm + 
                  I(mean_oxygen_roms_30_norm^2)")
  # wiggly environmental relationships?
  enviro <- ifelse(env_spline, paste0("s(mean_temp_roms_30_norm,k=",spline_k,") + ",
                                      "s(mean_oxygen_roms_30_norm,k=",spline_k,")"),
                   enviro)
  # if depth effect, add to model formla
  if(use_depth) {
    formula = paste0(formula, " + depth + I(depth^2)")
  }
  
  time_formula = "~ -1"
  if(time_vary) {
    time_formula = paste0(time_formula, " + ", substrate, " + ", enviro)
    time_varying = as.formula(time_formula)
    time = "year"
  } else {
    formula = paste0(formula, " + ", substrate, " + ", enviro)
    time_varying = NULL
    time = "year"
  }
  
  # fit model. EW commented out quadratic roots, since those are still experimental and won't work for all spp. Also turned
  # set.seed(41389) # for reproducibility
  # test_set = sample(1:nrow(modeldat), size = round(0.1*nrow(modeldat)), replace=FALSE)
  # modeldat$fold = 1
  # modeldat$fold[test_set] = 2
  # anisotropy off for now
  print('running model.')
  m <- try( sdmTMB(
    formula = as.formula(formula),
    time_varying = time_varying,
    spde = spde,
    time = time,
    family = tweedie(link = "log"),
    data = modeldat,
    anisotropy = FALSE,
    spatial_only = T,
    #extra_time argument necessary for prediction?
    extra_time=1980:2100,
    control=sdmTMBcontrol(map_rf=ifelse(spatial_field,F,T))
  ),
  silent=F)


  # predicted values for the 2nd fold (test)
  # m_cv$data$cv_predicted[which(m_cv$data$cv_fold==2)]
  # log likelihood values for the 2nd fold (test)
  # m_cv$data$cv_loglik[which(m_cv$data$cv_fold==2)]

    # sum(m_cv$data$cv_loglik[which(m_cv$data$cv_fold==2)])
  
  # if(class(m)!="try-error") {
  #   write_rds(m, file=here::here('model output',
  #                                paste0(spp,'.rds')))
  # }
  if(class(m)=="try-error"){
    print(paste("Error."))
  }else{
    print(paste("Model for",spp,"complete."))
  }

  # return(m)
  return(m)

}
```

## Cross Validation Function

Similar to the function above, this function implements 2-fold cross-validation in order to return the CV log-likelihood for use in model stacking and model ensembles.

```{r}
run_sdmTMB_cv <- function(dat,spp,nknots=400,use_depth=F,time_vary=F,spatial_field=T,include_substrate=T,hab_spline=F,env_spline=F,spline_k=3,return_what='loglik'){
  # filter data for species
  modeldat <- prepare_species(dat,spp=spp)
  
  # make spde
  spde <- make_mesh(modeldat,xy_cols = c('longitude','latitude'), 
                   cutoff = 20)
  
  # model formula
  formula <- paste0("cpue_kg_km2 ~ ")
  
  # substrate relationship
  substrate <- paste("prop_hard_mixed + I(prop_hard_mixed^2)")
  #wiggly habitat relationship?
  substrate <- ifelse(hab_spline, paste0("s(prop_hard_mixed,k=",spline_k,")"),
                      substrate)
  
  if(!include_substrate) substrate=""
  
  # make the environmental effects
  enviro <- paste("mean_temp_roms_30_norm + I(mean_temp_roms_30_norm^2) + mean_oxygen_roms_30_norm + I(mean_oxygen_roms_30_norm^2)")
  # wiggly environmental relationships?
  enviro <- ifelse(env_spline, paste0("s(mean_temp_roms_30_norm,k=",spline_k,") + ",
                                      "s(mean_oxygen_roms_30_norm,k=",spline_k,")"),
                   enviro)
  # if depth effect, add to model formla
  if(use_depth) {
    formula = paste0(formula, " + depth + I(depth^2)")
  }
  
  time_formula = "~ -1"
  
  if(time_vary) {
    time_formula = paste0(time_formula, " + ", substrate, " + ", enviro)
    time_varying = as.formula(time_formula)
    time = "year"
  } else {
    formula = paste0(formula, " + ", substrate, " + ", enviro)
    time_varying = NULL
    time = "year"
  }
  
  # fit model. EW commented out quadratic roots, since those are still experimental and won't work for all spp. Also turned
  set.seed(41389) # for reproducibility
  test_set = sample(1:nrow(modeldat), size = round(0.1*nrow(modeldat)), replace=FALSE)
  modeldat$fold = 1
  modeldat$fold[test_set] = 2 
  
  print('running 2-fold CV.')
  
  m_cv <- try( sdmTMB_cv( 
    formula = as.formula(formula),
    k_folds=2,
    parallel = TRUE,
    fold_ids = modeldat$fold,
    time_varying = time_varying,
    spde = spde,
    time = time,
    family = tweedie(link = "log"),
    data = modeldat,
    anisotropy = FALSE,
    spatial_only = T,
    #extra_time argument necessary for prediction?
    # extra_time=1980:2100,
    control=sdmTMBcontrol(map_rf=ifelse(spatial_field,F,T))
  ),
  silent=T)
  if(class(m_cv)=='try-error'){
    print(paste('Error.'))
  } else{
    # tem <- m_cv %>% pluck('data')
    # print(paste('data is class',class(tem)))
    total_pred_ll = m_cv %>% 
      pluck('data') %>% 
      dplyr::filter(cv_fold==2) %>% 
      pluck('cv_loglik') %>% 
      sum()
    if(return_what=='model') return(m_cv)
    else return(total_pred_ll)
  }
}
```

## Model Stacking Function

This function takes a list of models from running the equations, stacks their posterior predictive distributions, and returns appropriate likelihood-based model weights for use in creating ensemble predictions.

```{r}
sdmTMB_stacking <- function (model_list, include_folds = NULL) 
{
    n_models <- length(model_list)
    if (is.null(include_folds)) {
        n_folds <- max(model_list[[1]]$data$cv_fold)
        include_folds <- seq_len(n_folds)
    }
    X <- matrix(0, nrow = nrow(model_list[[1]]$data), ncol = n_models)
    for (i in 1:n_models) X[, i] = model_list[[i]]$data$cv_loglik
    X <- X[which(model_list[[1]]$data$cv_fold %in% include_folds), 
        ]
    X <- exp(X)
    tot_ll = function(p, X) {
        z <- matrix(exp(p)/sum(exp(p)), ncol = 1)
        k <- log(X%*%z)
        -sum(k[which(!is.infinite(k))])
    }
    o <- optim(par = runif(n_models), fn = tot_ll, X = X)
    weights <- exp(o$par)/sum(exp(o$par))
    return(weights)
}
```

## Model Fitting Wrapper

This final, wrapper function uses the functions above to fit a series of models using `run_sdmTMB`, compare them to one another using `run_sdmTMB_cv` and `sdmTMB_stacking`, and output a nested data frame including all models, their associated options (e.g., inclusion of spatial fields, linear or GAM-type environmental relationships), and importantly, their weights to use in the ensembling of model predictions.


```{r}
model_species <- function(spp,data,use_substrate=T){

  if(!use_substrate) {
    models_to_run <-crossing(spp,spatial_field=c(F,T),env_spline=c(F,T),include_substrate=F) %>%
      mutate(model_num=row_number())
    
    out <- models_to_run %>% 
      mutate(model=purrr::pmap(list(spp=spp,spatial_field=spatial_field,env_spline=env_spline,include_substrate=include_substrate),run_sdmTMB,dat=data)) %>%
      mutate(model_cv=purrr::pmap(list(spp=spp,spatial_field=spatial_field,env_spline=env_spline,include_substrate=include_substrate),run_sdmTMB_cv,dat=data,return_what="model"))
    
  } else {
    models_to_run <- crossing(spp,spatial_field=c(F,T),hab_spline=c(F,T),env_spline=c(F,T)) %>%
      mutate(model_num=row_number())
    out <- models_to_run %>% 
      mutate(model=purrr::pmap(list(spp=spp,spatial_field=spatial_field,hab_spline=hab_spline,env_spline=env_spline),run_sdmTMB,dat=data)) %>%
      mutate(model_cv=purrr::pmap(list(spp=spp,spatial_field=spatial_field,hab_spline=hab_spline,env_spline=env_spline),run_sdmTMB_cv,dat=data,return_what="model"))
  }
  
  
  model_weights <- try(sdmTMB_stacking(out$model_cv))
  if(class(model_weights)=='try-error'){
    print(paste('Error in model stacking.'))
    out$weight=NA
  } else{
    out$weight=model_weights
  }

  out
}
```

# Functions for Projection

## Single Model Projection

Function to make predictions for one model, using the "midpoint" environmental data (i.e., the 30 day lag from July 31st). In addition, the model makes a prediction using one the RCP8.5 scenario data from one of the three Earth System Models: Hadley, GFDL, or IPSL.

```{r}
# give the function a model object from sdmTMB, and a global climate model, either 'hadl','gfdl', 'ipsl'
make_predictions <- function(modelobj,gcm="hadl"){

  original_model_data <- modelobj$data
  # need to use the original (hindcast) environmental data to scale the projected data
  mean_t <- mean(original_model_data$mean_temp_roms_30,na.rm=T)
  sd_t <- sd(original_model_data$mean_temp_roms_30,na.rm=T)
  mean_oxy <- mean(original_model_data$mean_oxygen_roms_30,na.rm=T)
  sd_oxy <- sd(original_model_data$mean_oxygen_roms_30,na.rm=T)
  
  # create a new tibble with the projected data for the chosen gcm
  newdata <- roms %>% 
    ## NOTE: WE LOSE A TON OF DATA HERE, SOMETHING MAY BE WRONG WITH THE HABITAT DATA
    left_join(hab,by=c("lat","lon")) %>% 
    drop_na() %>% 
    dplyr::select(year,lat,lon,latitude,longitude,prop_hard_mixed,depth_m,contains(paste0("30d_",gcm)))
  
  temperature <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('temperature') %>% 
    mutate(mean_temp_roms_30_norm=(temperature-mean_t)/sd_t)
  
  oxygen <- newdata %>% dplyr::select(contains('oxy')) %>% 
    set_names('oxygen') %>% 
    mutate(mean_oxygen_roms_30_norm=(oxygen-mean_oxy)/sd_oxy)

  newdata <- newdata %>% 
    bind_cols(temperature) %>% 
    bind_cols(oxygen) %>% 
    dplyr::select(-temperature,-oxygen) %>%
    mutate(year=as.double(year))
  
  # years to predict
  yrs <- sort(unique(newdata$year))
  # now we can make the predictions
  predicted_cpue_km2 <- predict(modelobj,newdata,return_tmb_object=T,extra_time=yrs)
  
  predicted_cpue_km2
}
```

## Ensemble Predictions

To create ensemble predictions, we calculate predictions for each species' model separately, then weight them using the weights established in model fitting (i.e., from `sdmTMB_stacking`). This function takes as input the dataframe result of the `model_species` function above, then makes ensemble predictions using the projections from an ESM of choice (Hadley, GFDL, or IPSL). Returns a dataframe of predicted log CPUE.

```{r}
# this function is meant to be run with a list of models that all are fit on the same data, with a common set of predictors
ensemble_predictions <- function(model_df,gcm='hadl'){
  
  # use the first model in the list to pull out the data
  original_model_data <- model_df %>% pluck('model',1,'data')
  # need to use the original (hindcast) environmental data to scale the projected data
  mean_t <- mean(original_model_data$mean_temp_roms_30,na.rm=T)
  sd_t <- sd(original_model_data$mean_temp_roms_30,na.rm=T)
  mean_oxy <- mean(original_model_data$mean_oxygen_roms_30,na.rm=T)
  sd_oxy <- sd(original_model_data$mean_oxygen_roms_30,na.rm=T)
  
  # create a new tibble with the projected data for the chosen gcm
  newdata <- roms %>% 
    ## NOTE: WE LOSE A TON OF DATA HERE, SOMETHING MAY BE WRONG WITH THE HABITAT DATA
    left_join(hab,by=c("lat","lon")) %>% 
    drop_na() %>% 
    dplyr::select(year,lat,lon,latitude,longitude,prop_hard_mixed,depth_m,contains(paste0("30d_",gcm)))
  
  temperature <- newdata %>% dplyr::select(contains('bt')) %>% 
    set_names('temperature') %>% 
    mutate(mean_temp_roms_30_norm=(temperature-mean_t)/sd_t)
  
  oxygen <- newdata %>% dplyr::select(contains('oxy')) %>% 
    set_names('oxygen') %>% 
    mutate(mean_oxygen_roms_30_norm=(oxygen-mean_oxy)/sd_oxy)

  newdata <- newdata %>% 
    bind_cols(temperature) %>% 
    bind_cols(oxygen) %>% 
    dplyr::select(-temperature,-oxygen) %>%
    mutate(year=as.double(year))
  
  # years to predict
  yrs <- sort(unique(newdata$year))
  
  # model weights
  w <- model_df %>% pluck('weight')
  w <- ifelse(all(is.na(w)),rep(1,length(w)),w)
  
  model_list <- model_df %>% pluck('model')
  
  # make the predictions for all 8 models
  all_predictions <- purrr::map2_df(model_list,w,function(m,weight){
    preds <- predict(m,newdata=newdata,return_tmb_object=F,extra_time=yrs) %>% 
      mutate(weight=weight)
    preds
  })
  ens_preds <- all_predictions %>% 
    group_by(year,longitude,latitude,lat,lon,depth_m) %>% 
    summarise(ens_est=weighted.mean(est,weight)) %>% 
    ungroup()
  
  ens_preds
}
```

# Visualizing Outputs

After models have been fit and projected using trawl survey and ROMS data, we have a lot of ways to visualize the outputs.

## Annual Map

Rasterized grid for mapping prediction outputs.

```{r}
# pretty grid for raster maps
gr <- projection_extent %>% st_make_grid(cellsize=10,what='centers') %>% st_as_sf() %>% 
  st_intersection(projection_extent)
gr_xy <- st_coordinates(gr)
```

Function that maps SDM output for one year or a mean from a range of years (param `yr_vec`). Options to return the predicted data instead of the plot (`return_pred_df`) or whether or not to plot the legend (`plot_leg`)

```{r}
map_year <- function(model_ens,yr_vec=c(2000),return_pred_df=F,plot_leg=T){
  # scale for the legend, common within species
  scl <- c(0,quantile(exp(model_ens$ens_est),0.99))
  df <- model_ens %>% 
    filter(year%in%yr_vec) %>% 
    group_by(longitude,latitude) %>% 
    summarise(est=mean(ens_est,na.rm=T) %>% exp()) %>% 
    # rescale super large positive outliers for mapping purposes
    mutate(est=ifelse(est>scl[2],scl[2],est))
  # match nearest neighbors from predictions to grid
  pred_points <- df %>% dplyr::select(longitude,latitude) %>% as.matrix()
  nns <- nn2(pred_points,gr_xy,k=1)$nn.idx
  gr_pred <- gr_xy %>% as_tibble() %>% mutate(est=df$est[nns])
  
  bbox=st_bbox(projection_extent)
  
  if(return_pred_df) {out <- gr_pred %>% as_tibble()}
  
  else{
    out<-ggplot(coast)+
      geom_sf()+
      # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
      # scale_color_viridis_c()+
      geom_raster(data=gr_pred,aes(x=X,y=Y,fill=est),interpolate=F)+
      scale_fill_viridis_c(limits=scl)+
      xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
      labs(x="",y="",fill="CPUE",title='')
    if(!plot_leg) out <- out + theme(legend.position = 'None')
  }
  out
}
```

## Multispecies Map

Map overlap between multiple species

```{r}
map_multispp_year <- function(multi_ens,yr=2020,qlower=0.05,qupper=0.95){
  df <- multi_ens %>% 
    filter(year==yr) %>% 
    # find quantiles for each species
    group_by(species) %>% 
    mutate(qlow=quantile(ens_est,qlower),qhigh=quantile(ens_est,qupper)) %>% 
    mutate(presence=ifelse(ens_est>=qlow&ens_est<=qhigh,1,0)) %>% 
    ungroup() %>% 
    group_by(longitude,latitude) %>% 
    summarise(sumspp=sum(presence))
  # match nearest neighbors from predictions to grid
  pred_points <- df %>% dplyr::select(longitude,latitude) %>% as.matrix()
  nns <- nn2(pred_points,gr_xy,k=1)$nn.idx
  gr_pred <- gr_xy %>% as_tibble() %>% mutate(sumspp=df$sumspp[nns])
  
  bbox=st_bbox(projection_extent)

  out<-ggplot()+
    # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
    # scale_color_viridis_c()+
    geom_raster(data=gr_pred,aes(x=X,y=Y,fill=factor(sumspp)),interpolate=F)+
    scale_fill_manual(values=rev(viridis_pal(option="C",begin=0.2,end=0.8)(5)))+
    geom_sf(data=footprints,fill=NA,col='black')+
    geom_sf(data=coast)+
    coord_sf(datum=NA)+
    xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
    labs(x="",y="",fill="# Species",title='')+
    theme(legend.position=c(0.55,0.6))

  out
}
```


## Difference Map

Compare a map for a given year to the historical, 1980-2010 average.

```{r}
make_comparison_map <- function(model_ens,yr=2050){
  basepred <- map_year(model_ens,yr_vec=1980:2010,return_pred_df = T)
  newpred <- map_year(model_ens,yr_vec=yr,return_pred_df = T) %>% 
    mutate(est_comp=est) %>% dplyr::select(-est)
  both <- basepred %>% 
    left_join(newpred,by=c('X','Y')) %>% 
    mutate(diffpred=est_comp-est)
  
  bbox=st_bbox(projection_extent)
  
  out<-ggplot(coast)+
        geom_sf()+
        # geom_point(data=df,aes(longitude,latitude,col=exp(est)))+
        # scale_color_viridis_c()+
        geom_raster(data=both,aes(x=X,y=Y,fill=diffpred),interpolate=F)+
        scale_fill_gradient2(low = "red", mid = "white", high = "purple")+
        # scale_fill_viridis_c(direction = -1)+
        xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
        labs(x="",y="",fill="Difference")
  out
}
```

## Index of Abundance

Calculate an ensemble index of abundance. This function takes as input the dataframe result of the `model_species` function above, then makes a weighted, ensemble index of abundance using the projections from an ESM of choice (Hadley, GFDL, or IPSL) and the function `sdmTMB::get_index`.

```{r}
make_index <- function(model_df,gcm='hadl'){
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
    # model weights
  w <- model_df %>% pluck('weight')
  if(all(is.na(w))) w <- rep(1,nrow(model_df))
  # tic('making predictions')
  predictions_list <- model_df %>% pluck('model') %>% 
    purrr::map(make_predictions,gcm=gcm) 
  # toc()
  
  # tic('making indices')
  
  indices <- predictions_list %>% purrr::map_dfr(get_index)
  toc()
  
  nyr <- length(unique(indices$year))
  ws <- rep(w,each=nyr)
  
  # combined index
  ind <- indices %>%
    mutate(weight=ws) %>% 
    group_by(year) %>% 
    summarise(w.est=weighted.mean(est,w=weight)) %>% 
    ungroup()
  
  p <- ind %>%
    # ggplot(aes(year,est/1000,ymax=upr/1000,ymin=lwr/1000))+
    ggplot(aes(year,w.est/1000))+
    geom_line()+
    # geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,2))+
    labs(x="Year",y="Index of Abundance",title=paste(sppname, "Ensemble Abundance Index"))
  p
}
```

## Center of Gravity

Calculate an ensemble center of gravity time series or map. This function takes as input the dataframe result of the `model_species` function above, then makes a weighted, ensemble index of abundance using the projections from an ESM of choice (Hadley, GFDL, or IPSL) and the function `sdmTMB::get_cog`. User can choose whether to output a plot (`what='plot'`) or a dataframe recording ensemble COG over time.

```{r}
make_cog <- function(model_df,gcm='hadl',what="plot"){
  
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
  
  # model weights
  w <- model_df %>% pluck('weight')
  if(all(is.na(w))) w <- rep(1,nrow(model_df))
  
  # tic('making predictions')
  predictions_list <- model_df %>% pluck('model') %>% 
    purrr::map(make_predictions,gcm=gcm) 
  # toc()
  
  # tic('making cogs')
  
  cogs <- predictions_list %>% purrr::map_dfr(get_cog)
  # toc()
  
  nyr <- length(unique(cogs$year))
  ws <- rep(w,each=nyr)
  
  
# reorganize output (X and Y coords)
  cog_x <- cogs %>% 
    filter(coord=="X")%>% 
    rename_with(~paste0(.,"_x"),all_of(c('est','lwr','upr','se'))) %>% 
    dplyr::select(-coord) %>% 
    # add weights
    mutate(weight=ws) %>% 
    group_by(year) %>% 
    summarise(w.est_x=weighted.mean(est_x,w=weight)) %>% 
    ungroup()
  cog_y <- cogs %>% 
    filter(coord=="Y") %>% 
    rename_with(~paste0(.,"_y"),all_of(c('est','lwr','upr','se')))%>% 
    dplyr::select(-coord) %>% 
    # add weights
    mutate(weight=ws) %>% 
    group_by(year) %>% 
    summarise(w.est_y=weighted.mean(est_y,w=weight)) %>% 
    ungroup()
  cog_2d <- cog_x %>% left_join(cog_y,by='year')
  
  cog_x_plot <- cog_2d %>% 
    # ggplot(aes(year,w.est_x,ymax=upr_x,ymin=lwr_x))+
    ggplot(aes(year,w.est_x))+
    geom_line()+
    # geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,5))+
    labs(x="Year",y="Eastings (km)",title="Center of Gravity, X")
  
  cog_y_plot <- cog_2d %>% 
    # ggplot(aes(year,w.est_y,ymax=upr_y,ymin=lwr_y))+
    ggplot(aes(year,w.est_y))+
    geom_line()+
    # geom_ribbon(fill='red',alpha=0.5)+
    scale_x_continuous(expand=c(0,5))+
    labs(x="Year",y="Northings (km)",title="Center of Gravity, Y")
  
  cog2d_timeseries <- plot_grid(cog_x_plot,cog_y_plot,nrow=2)
  
  cog_2d_sf <- cog_2d %>% st_as_sf(coords=c('w.est_x','w.est_y'),crs="+proj=utm +zone=10 +datum=WGS84 +units=km")

  bbox <- st_bbox(projection_extent)

  cog_spatial <- ggplot()+
      geom_sf(data=coast)+
      geom_sf(data=cog_2d_sf,aes(col=year))+
      labs(title=paste(sppname,"Center of Gravity"),col="Year")+
      xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])

  out <- plot_grid(cog_spatial,cog2d_timeseries,ncol=2)
  if(what=="plot") return(out) else return(cog_2d)
}
```

## Depth Distribution

Calculate and plot a comparative cumulative depth distribution. This function takes as input the ensemble predictions for a species (i.e, the output of `ensemble_predictions`), then compares the depth distribution of two years of data (default 2020 and 2100).

```{r}
plot_depth_distribution <- function(ens_preds,name="",start_year=2020,end_year=2100){
  y <- ens_preds %>% 
    filter(year==start_year|year==end_year) %>%
    mutate(cpue=exp(ens_est)) %>% 
    rename(depth=depth_m) %>% 
    group_by(year,depth) %>% 
    summarise(cpue=mean(cpue,na.rm=T)) %>% 
    ungroup() %>% 
    group_by(year) %>% 
    mutate(prop_cpue=cpue/sum(cpue,na.rm=T)) %>%
    arrange(desc(depth)) %>% 
    mutate(cum_cpue=cumsum(prop_cpue)) %>% 
    ungroup()
  y %>% 
    ggplot(aes(depth,cum_cpue,col=factor(year)))+
    geom_line(size=2)+
    xlim(-1280,0)+
    # 700 fathom line
    # geom_vline(xintercept=-1280.16,linetype=2)+
    coord_flip()+
    scale_color_manual(values=c("#2271B2","#d55e00"))+
    labs(x="Depth (m)",y="Cumulative CPUE",title="",col="Year")
}
```

Option 2: Fraction of estimated CPUE that is deeper than 700 fathoms (~1280m)
```{r}

pal4 <- viridis_pal(option="A",begin=0.2,end=0.8)(4)
plot_depth_distribution2 <- function(ens_preds,start_year=2020,end_year=2100){
  y <- ens_preds %>% 
    mutate(spp_plotting=case_when(
      species=='dover' ~ "Dover Sole",
      species=="ls_thornyhead" ~ "Longspine",
      species=="ss_thornyhead"~"Shortspine",
      species=="sable" ~"Sablefish"
    )) %>% 
    mutate(spp_plotting=factor(spp_plotting,levels=c("Dover Sole","Sablefish","Shortspine","Longspine"))) %>% 
    filter(year>=start_year,year<=end_year) %>%
    mutate(cpue=exp(ens_est)) %>% 
    rename(depth=depth_m) %>% 
    group_by(spp_plotting,year,depth) %>% 
    summarise(cpue=mean(cpue,na.rm=T)) %>% 
    ungroup() %>% 
    group_by(spp_plotting,year) %>% 
    mutate(prop_cpue=cpue/sum(cpue,na.rm=T)) %>%
    ungroup() %>% 
    mutate(is_deep=depth < -1280) %>% 
    group_by(spp_plotting,year,is_deep) %>% 
    summarise(prop=sum(prop_cpue)) %>%
    ungroup()
  y %>% 
    filter(!is_deep) %>% 
    ggplot(aes(year,prop,col=spp_plotting))+
    geom_line(size=1.5)+
    scale_color_manual(values=pal4)+
    # scale_color_manual(values=c("#2271B2","#d55e00"))+
    labs(x="Year",y="Proportion CPUE Shallower than\n700 fathoms",title="",col="Species")+
    theme(axis.text.x=element_text(size=10),
          axis.text.y=element_text(size=10))
}
```


## Distance from Shore

Using data on the distance of each ROMS cell from the coastline, calculate an ensemble weighted "distance from shore centroid" for each 0.1deg latitude band in each year. This function takes as input the ensemble predictions for a species (i.e, the output of `ensemble_predictions`).

```{r}
plot_dist_to_shore <- function(ens_preds,include_legend=T){
  d <- ens_preds %>% 
    left_join(roms_dist_to_coast,by=c("longitude","latitude")) %>% 
    group_by(year,lat) %>% 
    mutate(totest = sum(exp(ens_est))) %>% 
    mutate(rel_est=exp(ens_est)/totest) %>% 
    mutate(w.dist=rel_est*km_to_coast) %>% 
    summarise(w.dist=sum(w.dist)) %>% 
    ungroup()
  if(include_legend){
      p <- d %>% 
        ggplot(aes(lat,w.dist,col=year,group=year))+
        geom_line()+
        scale_color_viridis(option="A")+
        scale_y_reverse(limits=c(90,20))+
        coord_flip()+
        # theme(legend.position = c(0.8,0.7))+
        labs(y="Distance from Shore (km)",x="Latitude",col="Year")
  } else {
      p <- d %>% 
        ggplot(aes(lat,w.dist,col=year,group=year))+
        geom_line()+
        scale_color_viridis(option="A",guide="none")+
        scale_y_reverse(limits=c(90,20))+
        coord_flip()+
        labs(y="",x="",col="")
  }

  p
}
```

Similar to the above, this calculates a map rather than a line plot.

```{r}
create_lines <- function(df){
  lines <- df %>%
    group_by(lat) %>% 
    mutate(totest = sum(exp(ens_est))) %>% 
    mutate(rel_est=exp(ens_est)/totest) %>% 
    mutate(w.lon=rel_est*lon) %>% 
    summarise(w.lon=sum(w.lon)) %>% 
    ungroup() %>% 
    st_as_sf(coords=c("w.lon","lat"),crs=4326) %>% 
    st_transform(st_crs(coast)) %>% 
    st_coordinates() %>% st_linestring()
}

map_dist_to_shore <- function(ens_preds,include_legend=T){
  d <- ens_preds %>% 
    group_by(year) %>% 
    nest() %>% 
    mutate(centroid_line=purrr::map(data,create_lines)) %>% 
    ungroup() %>% 
    dplyr::select(year,centroid_line) %>% 
    st_as_sf() %>% 
    st_set_crs(st_crs(coast))
  bbox <- st_bbox(d)
  if(include_legend){
      p <-ggplot()+
        geom_sf(data=coast,color='gray50')+
        geom_sf(data=d,aes(col=year))+
        coord_sf(datum=NA)+
        scale_color_viridis(option="A")+
        xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
        labs(y="",x="",col="Year")+
        theme(plot.margin = unit(c(0,0,0,0), "cm"))
  } else {
      p <-ggplot()+
        geom_sf(data=coast,color='gray50')+
        geom_sf(data=d,aes(col=year))+
        coord_sf(datum=NA)+
        scale_color_viridis(option="A",guide="none")+
        xlim(bbox[1],bbox[3])+ylim(bbox[2],bbox[4])+
        labs(y="",x="",col="Year")+
        theme(plot.margin = unit(c(0,0,0,0), "cm"))
  }

  p
}
```


## Hovmoller Plots

Make side-by-side, Hovmoller-type plots of predicted species' CPUE by depth and latitude over time.

```{r}
make_hov <- function(model_df,gcm='hadl'){
  
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
  gcmname <- switch(gcm,hadl="Hadley",gfdl="GFDL",ipsl = "IPSL")
  
  df_pred <- ensemble_predictions(model_df,gcm=gcm)
  
  depthbins <- seq(-3500,0,by=100)
  latbins <- seq(30,50,by=0.5)
  
  out <- df_pred %>% 
    # add lat and depth bins
    mutate(latbin=latbins[findInterval(lat,vec=latbins)],
           depthbin=depthbins[findInterval(depth_m,vec=depthbins)]) %>% 
    ungroup()
  
  #summarize data by year/lat or year/depth
  
  outlat <- out %>% 
    group_by(year,latbin) %>% 
    summarise(mean_cpue=mean(ens_est,na.rm=T))
  
  outdepth <- out %>% 
    group_by(year,depthbin) %>% 
    summarise(mean_cpue=mean(ens_est,na.rm=T)) %>% 
    filter(depthbin>-2001)
  
  p1 <- outlat %>% 
    ggplot(aes(year,latbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$ens_est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="",x="Year",y="Latitude")
  
  p2 <- outdepth %>% 
    ggplot(aes(year,depthbin,fill=mean_cpue))+
    geom_tile()+
    scale_fill_gradient2(
        low = 'blue', mid = 'white', high = 'red',
        midpoint = mean(out$ens_est,na.rm=T))+
    scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand=c(0,0),breaks = seq(-3500,0,by=300),labels=seq(-3500,0,by=300))+
    theme_classic()+
    theme(legend.position="right",
          legend.title = element_blank(),
          plot.title = element_text(size = 14),
          plot.subtitle = element_text(size = 12)) +
    theme( panel.border = element_rect(colour = "black", fill=NA, size=1))+
    labs(title="",x="Year",y="Depth")
  
  comb <- plot_grid(p1,p2,nrow=1)
  # titlegg <- ggdraw() +
  #   draw_label(paste(sppname,gcmname))
  # plot_grid(titlegg,comb,ncol = 1, rel_heights = c(0.2, 1))
  comb
}
```

## Environmental Affinities Raster

Plot a raster heatmap of relative species CPUE across the range of bottom temperature and oxygen values found in the data. This function takes as input the ensemble predictions for a species (i.e, the output of `ensemble_predictions`), as well as a template raster of oxygen and temperature values.

```{r}
rasterize_affinities <- function(ens_preds,template_raster,return_what="plot"){

  ul <- quantile(ens_preds$ens_est,0.99)
  ll <- quantile(ens_preds$ens_est,0.01)
  dsf <- ens_preds %>% 
    filter(ens_est>ll,ens_est<ul) %>%
    mutate(abun=exp(ens_est)) %>% 
    mutate(rel_abun=abun/max(abun,na.rm=T)) %>% 
    st_as_sf(coords=c("mean_bt_30d_ipsl","mean_oxy_bottom_30d_ipsl"))
  spp_r <- dsf %>% raster::rasterize(template_raster,field="rel_abun",fun=mean)
  spp_df <- spp_r %>% raster::rasterToPoints() %>% as_tibble() %>% set_names(c('temp','oxy','abun')) %>%
    mutate(species=unique(ens_preds$species))
  # spp_df
  
  # make the plot
    
  mainp <- spp_df %>% 
    ggplot(aes(temp,oxy,fill=abun))+
    geom_tile()+
    scale_fill_viridis(na.value='white',name="Relative\nAbundance",breaks=c(0,0.25,0.5,0.75,1))+
    labs(x="",y="",title='')+
    theme(panel.background = element_rect(fill='white'),
          # panel.background = element_rect(fill=viridis_pal()(1)),
          # legend.position = c(0.1,0.7),
          # legend.background = element_rect(fill='white'),
          panel.grid.major = element_blank(),
          panel.grid.minor=element_blank())
  
  if(return_what=="legend") return(get_legend(mainp))
  else{
      
  m1 <- spp_df %>% group_by(temp) %>% summarise(m=sum(abun)) %>% 
    ggplot(aes(temp,m))+geom_area(fill='grey50')+theme_void()+
    theme(plot.margin = margin(0,-0.1,-0.1,0,'cm'))
  
  m2 <- spp_df %>% group_by(oxy) %>% summarise(m=sum(abun)) %>% 
    ggplot(aes(oxy,m))+geom_area(fill='grey50')+theme_void()+coord_flip()+
    theme(plot.margin = margin(0,0,0,0,'cm'))
  
  col1 <- plot_grid(m1,NULL,mainp+theme(legend.position='none',plot.margin = margin(0,0,0,0,'pt')),nrow=3,align='v',axis='lr',rel_heights = c(0.2,-0.07,1))
  # grobs <- ggplotGrob(row1)
  # g <- grid::rectGrob(gp = grid::gpar(col=0))
  # row1 <- plot_grid(NULL,m1,NULL,nrow=1,rel_widths = c(0.5,5,1.15))
  col2 <- plot_grid(NULL,m2,NULL,nrow=3,rel_heights = c(0.25,1,0.15))
  out <- plot_grid(col1,col2,ncol=2,rel_widths =c(1,0.25))
  # out <- plot_grid(m1,NULL,mainp+rremove('legend')+rremove(),m2,ncol=2,align='hv',rel_widths = c(1,0.25),rel_heights = c(0.25,1))
  out
  }

}
```

## Environmental Affinities Ellipses

Find weighted mean and SD of species' temperature and oxygen tolerances

```{r}

# x <- dover_ens %>% filter(year %in% 1980:2022) %>% mutate(expest=exp(ens_est)) %>% arrange(expest) %>% mutate(cumest=cumsum(expest)) %>% mutate(obs=row_number(),)
# just weighted mean/sd temperature and oxygen
weighted_affinities <- function(ens_preds,yrs=c(1980:2022)){
  ens_preds %>% 
    filter(year %in% yrs) %>%
    group_by(species) %>%
    mutate(ens_est=exp(ens_est)) %>% 
    summarise(w.t=wtd.mean(mean_bt_30d_ipsl,ens_est,normwt = T),
              w.o=wtd.mean(mean_oxy_bottom_30d_ipsl,ens_est,normwt = T),
              var.t=wtd.var(mean_bt_30d_ipsl,ens_est,normwt=T),
              var.o=wtd.var(mean_oxy_bottom_30d_ipsl,ens_est,normwt=T),
              sd.t=sqrt(var.t),
              sd.o=sqrt(var.o),
              t.q5=wtd.quantile(mean_bt_30d_ipsl,ens_est,probs=0.05,normwt = T),
              t.q95=wtd.quantile(mean_bt_30d_ipsl,ens_est,probs=0.95,normwt = T),
              o.q5=wtd.quantile(mean_oxy_bottom_30d_ipsl,ens_est,probs=0.05,normwt = T),
              o.q95=wtd.quantile(mean_oxy_bottom_30d_ipsl,ens_est,probs=0.95,normwt = T)) %>% 
    ungroup() %>% 
    mutate(t.max=w.t+sd.t,t.min=w.t-sd.t,o.max=w.o+sd.o,o.min=w.o-sd.o)
}
# make the plotting df
```

```{r}
# Using package concaveman
# ens_preds =four_spp;yr_vec=1980:2022
require(concaveman)

make_spp_concave_hull <- function(ens_preds,yr_vec=1980:2022,sppname,concavity=5,threshold=0.05){
  df <- ens_preds %>% 
    filter(year %in% yr_vec) %>%
    mutate(ens_est=exp(ens_est)) %>%
    filter(ens_est>=quantile(ens_est,threshold)) %>% 
    ungroup() %>% 
    dplyr::select(mean_bt_30d_ipsl,mean_oxy_bottom_30d_ipsl) %>% 
    as.matrix()
    # st_as_sf(coords=c("mean_bt_30d_ipsl","mean_oxy_bottom_30d_ipsl"))
  p <- df %>% 
    concaveman(concavity = concavity) %>% 
    as_tibble() %>% 
    mutate(spp=sppname)
  p
}

affinities_ellipses <- function(ens_preds,yr_vec=1980:2022,concavity=3,threshold=0.25,return_what='df'){
  df <- ens_preds %>% 
    filter(year %in% yr_vec) %>%
    mutate(ens_est=exp(ens_est)) %>%
    dplyr::select(species,year,ens_est,mean_bt_30d_ipsl,mean_oxy_bottom_30d_ipsl) %>% 
    group_by(species) %>% 
    nest(data=c(year,ens_est,mean_bt_30d_ipsl,mean_oxy_bottom_30d_ipsl)) %>% 
    mutate(p=map(data,make_spp_concave_hull,sppname=species,concavity=concavity,threshold=threshold)) %>% 
    ungroup()
  
  ps <- do.call(rbind,df$p) %>% 
    mutate(spp_plotting=case_when(
      spp=='dover' ~ "Dover Sole",
      spp=="ls_thornyhead" ~ "Longspine",
      spp=="ss_thornyhead"~"Shortspine",
      spp=="sable" ~"Sablefish"
    )) %>% 
    mutate(spp_plotting=factor(spp_plotting,levels=c("Dover Sole","Sablefish","Shortspine","Longspine")))
  
  if(return_what=='plot'){
    out <- ps %>%
      ggplot(aes(V1,V2,col=spp_plotting))+
      geom_polygon(fill=NA,size=1.5)+
      scale_color_manual(values=pal4)+
      # scale_fill_manual(values=pal4)+
      labs(x="Bottom Temperature",y="Bottom Oxygen",col="Species")
  } else{
    out <- ps
  }
  out
}
```


## All Projection Plots

This is a final wrapper function to calculate and create all of the projection plots described above, saving them within a user-defined directory.

```{r}
# make and save all plots for a given model dataframe and a given GCM
save_projection_plots <- function(model_df,gcm='hadl',savedir=here::here('plots')){
  # make ensemble projection
  tic('making ensemble projections')
  projection <- ensemble_predictions(model_df,gcm=gcm)
  toc()
  
  # maps
  # historical average cpue
  tic('making maps')
  baseline_cpue <- map_year(projection,yr_vec=1980:2010)
  # 2050 and 2100 relative to baseline
  diff2050 <- make_comparison_map(projection,yr=2050)
  diff2100 <- make_comparison_map(projection,yr=2100)
  toc()
  
  # index of abundance, center of gravity, hovmoller plots
  tic('making abundance, cog, depth, distance from shore, and hovmoller plots')
  ind <- make_index(model_df,gcm=gcm)
  cog <- make_cog(model_df,gcm=gcm)
  ddist <- plot_depth_distribution(projection)
  cdist <- plot_dist_to_shore(projection,include_legend = T)
  hov <- make_hov(model_df,gcm=gcm)
  toc()
  
  # environmental relationships
  tic('making environmental relationships')
  env_sf <- projection %>%
    # join roms data
    left_join(roms) %>% 
    dplyr::select(year,dover:ls_thornyhead,mean_bt_30d_ipsl,mean_oxy_bottom_30d_ipsl) %>%
        st_as_sf(coords=c("mean_bt_30d_ipsl","mean_oxy_bottom_30d_ipsl"))
  tempr <- raster::raster(raster::extent(st_bbox(env_sf)),nrows=150,ncol=100)
  env <- rasterize_affinities(projection,template_raster = tempr)
  toc()
  
  # save everything to file
  tic('saving plots')
  sppname <- unique(model_df$spp) %>% tools::toTitleCase()
  savedir <- paste0(savedir,'/',sppname)
  dir.create(savedir)
  savedir <- paste0(savedir,'/',gcm)
  dir.create(savedir)
  
  ggsave(filename=paste0(savedir,'/baseline_cpue.png'),baseline_cpue)
  ggsave(filename=paste0(savedir,'/diff2050.png'),diff2050)
  ggsave(filename=paste0(savedir,'/diff2100.png'),diff2100)
  ggsave(filename=paste0(savedir,'/ind.png'),ind)
  ggsave(filename=paste0(savedir,'/cog.png'),cog)
  ggsave(filename=paste0(savedir,'/depth_distribution.png'),ddist)
  ggsave(filename=paste0(savedir,'/distance_to_coast.png'),cdist)
  ggsave(filename=paste0(savedir,'/hov.png'),hov)
  ggsave(filename=paste0(savedir,'/env_affinities.png'),env)
  
  toc()
}
```

# Species Overlap Metrics

Overlap metrics based on Carroll et al. (2019). These take the ensemble prediction outputs for two different species, produced by the `ensemble_predictions()` function above. The global index of collocation also requires the center of gravity calculations from `get_cog(what='df')`.

## Schoener's D

```{r}
#Schoener's D
schoeners <- function(dat1, dat2) {
  p1 <- dat1$ens_est %>% exp()
  p2 <- dat2$ens_est %>% exp()
  p_p1 <- p1/sum(p1, na.rm = T)
  p_p2 <- p2/sum(p2, na.rm = T)
  1 - 0.5 * (sum(abs(p_p1-p_p2), na.rm = T))
}
```

## Local Index of Collocation

```{r}
lic <- function(dat1,dat2) {
  p1 <- dat1$ens_est %>% exp()
  p2 <- dat2$ens_est %>% exp()
  p_p1 <- p1/sum(p1, na.rm = T)
  p_p2 <- p2/sum(p2, na.rm = T)
  sum(p_p1*p_p2, na.rm = T)/(sqrt(sum(p_p1^2, na.rm = T)*sum(p_p2^2, na.rm = T)))
}

# if you want the metric to be spatial (grid-scale)
lic_grid <- function(dat1,dat2) {
  p1 <- dat1$ens_est %>% exp()
  p2 <- dat2$ens_est %>% exp()
  p_p1 <- p1/sum(p1, na.rm = T)
  p_p2 <- p2/sum(p2, na.rm = T)
  lic_vec <- (p_p1*p_p2)/(sqrt(sum(p_p1^2)*sum(p_p2^2)))
  lic_vec
}
```

```{r,eval=F}
# relationship between LIC and D?
test <- crossing(k=seq(0,1000,length.out = 100),j=seq(0,1000,length.out = 100)) %>%
  mutate(pk=k/sum(k),pj=j/sum(j)) %>% 
  mutate(L=(pk*pj)/(sqrt(sum(pk^2)*sum(pj^2)))) %>% 
  mutate(Dpart=abs(pk-pj),D=1-0.5*Dpart)

licp <- test %>%
  ggplot(aes(k,j,fill=L))+
  geom_raster()+
  coord_equal()+
  scale_fill_viridis(option="A")+
  theme(legend.position = 'left',
        legend.text=element_text(size=10))
Dp <- test %>%
  ggplot(aes(k,j,fill=D))+
  geom_raster()+
  coord_equal()+
  scale_fill_viridis(option="A")+
  theme(legend.position = 'right',
        legend.text=element_text(size=10))
lic_d_plot <- plot_grid(licp,Dp,nrow=1)

# part 2
licp2 <- test %>% 
  filter(j==sort(unique(test$j))[50]) %>% 
  ggplot(aes(k,L))+
  geom_line()+
  annotate('text',x=200,y=0.000125,label="j=500",size=5)
Dp2 <- test %>% 
  filter(j==sort(unique(test$j))[50]) %>% 
  ggplot(aes(k,D))+
  geom_line()+
  annotate('text',x=200,y=0.99999,label="j=500",size=5)
lic_d_plot2 <- plot_grid(licp2,Dp2,nrow=1)
lic_d_plots <- plot_grid(lic_d_plot,lic_d_plot2,nrow=2,labels='auto')
# ggsave(here('model output','dts paper','lic_d_comparison.png'),lic_d_plots,w=8,h=6)
```


## Global Index of Collocation

```{r}
gic <- function(dat1,dat2,cog1,cog2){
  k_x <- dat1$longitude
  k_y <- dat1$latitude
  k <- dat1$ens_est %>% exp()
  k_cogx <- cog1$w.est_x
  k_cogy <- cog1$w.est_y
  j_x <- dat2$longitude
  j_y <- dat2$latitude
  j <- dat2$ens_est %>% exp()
  j_cogx <- cog2$w.est_x
  j_cogy <- cog2$w.est_y
  
  k_ix <- k_x-k_cogx
  k_iy <- k_y-k_cogy
  k_i <- sqrt(k_ix^2+k_iy^2)
  k_inert <- sum(k*(k_i^2),na.rm=T)/sum(k,na.rm=T)
  
  j_ix <- j_x-j_cogx
  j_iy <- j_y-j_cogy
  j_i <- sqrt(j_ix^2+j_iy^2)
  j_inert <- sum(j*(j_i^2),na.rm=T)/sum(j,na.rm=T)
  
  GIC <- (((k_cogx - j_cogx)^2+(k_cogy - j_cogy)^2)/ (((k_cogx-j_cogx)^2+(k_cogy-j_cogy)^2)+k_inert + j_inert))
  if(!is.na(GIC))
    GIC <- 1-GIC
  else GIC <- 1
  GIC
}
```

# Fishing Footprints

Calculate an ensemble CPUE density timeseries within particular port-based fishing footprints for the DTS trawl fleet. 

```{r}
calc_footprint_dens_ts <- function(ens_preds,fp=footprints,what="plot"){
  d <- ens_preds %>% 
    filter(year>2019) %>% 
    mutate(est=ens_est) %>%
    # mutate(est=exp(ens_est)) %>%
    st_as_sf(coords=c("longitude","latitude"),crs="+proj=utm +zone=10 +datum=WGS84 +units=km") %>% 
    st_join(footprints) %>% 
    st_set_geometry(NULL) %>% 
    filter(!is.na(port_name)) %>% 
    group_by(port_name,year) %>% 
    summarise(mean_cpue=mean(est,na.rm=T)) %>% 
    ungroup()
  if(what=="plot"){
    out <- d %>% 
      ggplot(aes(year,mean_cpue,col=port_name))+
      geom_line(size=1)+
      # geom_point(size=1)+
      # geom_smooth(se=F)+
      scale_color_npg()+
      labs(x="Year",y="Log CPUE (kg per sq. km)",col="Port Group")
      # theme(legend.position = "bottom")
  } else {out = d}
  
  out
}

# Could also calculate a relative change timeseries (% change from 2020 baseline)
calc_footprint_reldens_ts <- function(ens_preds,fp=footprints,what="plot"){
  d <- ens_preds %>% 
    filter(year>2019) %>% 
    mutate(est=exp(ens_est)) %>%
    # mutate(est=exp(ens_est)) %>%
    st_as_sf(coords=c("longitude","latitude"),crs="+proj=utm +zone=10 +datum=WGS84 +units=km") %>% 
    st_join(footprints) %>% 
    st_set_geometry(NULL) %>% 
    filter(!is.na(port_name)) %>% 
    group_by(port_name,year) %>% 
    summarise(mean_cpue=mean(est,na.rm=T)) %>% 
    # measure the difference from 2020 baseline
    ungroup() %>% 
    group_by(port_name) %>% 
    mutate(perc_change=(mean_cpue/mean_cpue[year==2020]*100-100)) %>% 
    ungroup()
  if(what=="plot"){
    out <- d %>% 
      ggplot(aes(year,perc_change,col=port_name))+
      geom_line(size=1)+
      # geom_point(size=1)+
      # geom_smooth(se=F)+
      scale_color_npg()+
      labs(x="Year",y="CPUE Change Relative to 2020 (%)",col="Port Group")
      # theme(legend.position = "bottom")
  } else {out = d}
  
  out
}
```

Can also use the footprints combined with `lic_grid` to calculate a similar timeseries for the value of the overlap index within fishing footprints over time.

```{r}
calc_footprint_overlap_ts <- function(ens1,ens2,fp=footprints){
  ens1l <- ens1 %>% group_split(year)
  ens2l<- ens2 %>% group_split(year)
  lic_vec <- purrr::map2(ens1l,ens2l,lic_grid) %>% unlist()
  overlap_ts <- ens1 %>% 
    dplyr::select(-ens_est) %>% 
    mutate(lic=lic_vec) %>% 
    # mutate(est=exp(ens_est)) %>%
    st_as_sf(coords=c("longitude","latitude"),crs="+proj=utm +zone=10 +datum=WGS84 +units=km") %>% 
    st_join(footprints) %>% 
    st_set_geometry(NULL) %>% 
    filter(!is.na(port_name)) %>% 
    group_by(port_name,year) %>% 
    summarise(sum_lic=sum(lic,na.rm=T)) %>% 
    ungroup()
  
  overlap_ts
}
```

